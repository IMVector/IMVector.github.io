<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Vector"><title>问题记录 · Vector</title><meta name="description" content="MathJax.Hub.Config({
tex2jax: {
  inlineMath: [['$','$'], ['\\(','\\)']],
  processEscapes: true
  }
});




一、Java 基础相关1.1 数据结构与算法1.1.1 常用的数据结构有哪些?1数"><meta name="keywords" content="Vector的小窝"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Vector</a></h3><div class="description"><p>没人扶你的时候，自己要站直，路还长，背影要美！</p></div></div></div><ul class="social-links"><li><a href="https://github.com/IMVector" target="_blank" rel="noopener"><i class="fa fa-github"></i></a></li><li><a href="mailto:1769326712@qq.com"><i class="fa fa-envelope"></i></a></li><li><a href="http://sighttp.qq.com/authd?IDKEY=" target="_blank" rel="noopener"><i class="fa fa-qq"></i></a></li><li><a href="https://zhihu.com/people/" target="_blank" rel="noopener"><i class="fa fa-mortar-board"></i></a></li></ul><div class="footer"><div class="p"> <span>© 2017 - 2020 </span><i class="fa fa-star"></i><span> Vector</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><a href="https://github.com/mrcore/hexo-theme-Anatole-Core" target="_blank">Anatole-Core.  </a><span> &</span><a href="https://github.com/IMVector/blog_vector" target="_blank">Vector.  </a><a href="http://www.beian.miit.gov.cn/" target="_blank">&nbsp;粤ICP备15011643号</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">标签</a></li><li><a href="/about">关于</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>问题记录</a></h3></div><div class="post-content"><!--将该代码放入博客模板的head中即可-->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
  inlineMath: [['$','$'], ['\\(','\\)']],
  processEscapes: true
  }
});
</script>
<!--latex数学显示公式-->
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<h1 id="一、Java-基础相关"><a href="#一、Java-基础相关" class="headerlink" title="一、Java 基础相关"></a>一、Java 基础相关</h1><h2 id="1-1-数据结构与算法"><a href="#1-1-数据结构与算法" class="headerlink" title="1.1 数据结构与算法"></a>1.1 数据结构与算法</h2><h3 id="1-1-1-常用的数据结构有哪些"><a href="#1-1-1-常用的数据结构有哪些" class="headerlink" title="1.1.1 常用的数据结构有哪些?"></a>1.1.1 常用的数据结构有哪些?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组、链表、树（二叉树、二叉搜索树、红黑树）、图（有向图，无向图）、栈、队列、散列表</span><br></pre></td></tr></table></figure>
<h3 id="1-1-2-数组"><a href="#1-1-2-数组" class="headerlink" title="1.1.2 数组"></a>1.1.2 数组</h3><p>（1）如何在一个 1 到 100 的整数数组中找到丢失的数字?<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">二分查找O（logn）</span><br><span class="line">哈希表O（n）</span><br></pre></td></tr></table></figure></p>
<p>（2）如何在给定的整数数组中找到重复的数字? （小米）<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">哈希表</span><br><span class="line">原地哈希表</span><br></pre></td></tr></table></figure></p>
<p>（3）如何在未排序整数数组中找到最大值和最小值?（字节跳动）</p>
<ul>
<li>使用两个值记录最大值和最小值, 每次取出两个值,先进行比较,小的与最小值比较,大的与最大值比较 , 比较次数: 1.5∗N</li>
<li>将相邻的数进行比较,大的放在偶数位置,小的放在奇数位置, 最后奇数位置比较和偶数位置对应比较,得到最大值和最小值,比较次数: $1.5∗N$ ;</li>
</ul>
<p><a href="https://www.cnblogs.com/hugochen1024/p/12570824.html" target="_blank" rel="noopener">東木:无序数组中求最大值和最小值的最少比较次数</a></p>
<p><a href="https://www.jianshu.com/p/96fa355e1faf" target="_blank" rel="noopener">作者：逃之不桃链接：来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</a><br>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路是类似于快速排序的分组方式，对数组从两头进行分组，</span></span><br><span class="line"><span class="comment">// 即第0个元素与第n-1个元素进行对比，大的放a组，小的放b组；</span></span><br><span class="line"><span class="comment">// 然后第一个与n-2进行对比........直到两边序号重合，比较次数为n/2，</span></span><br><span class="line"><span class="comment">// 这时，最大的数肯定在a组里，最小的数肯定在b组。</span></span><br><span class="line"><span class="comment">// 然后再在a组里寻找最大值，再在b组里寻找最小值，分别都是n/2次比较，</span></span><br><span class="line"><span class="comment">// 一共使用3/2n次比较就搞定啦。</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">findMaxandMinNumber</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分组</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; (count - i - <span class="number">1</span>); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]&lt;nums[count<span class="number">-1</span>-i]) &#123;</span><br><span class="line">            <span class="comment">//交换位置</span></span><br><span class="line">            <span class="keyword">int</span> tem = nums[i];</span><br><span class="line">            nums[i] = nums[count-i<span class="number">-1</span>];</span><br><span class="line">            nums[count-i<span class="number">-1</span>] = tem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sep = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> middle = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == count-i<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">//奇数</span></span><br><span class="line">        sep = count/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        middle = nums[count/<span class="number">2</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//偶数</span></span><br><span class="line">        sep = count/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//大的一组</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;count/<span class="number">2</span><span class="number">-1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j]&gt;<span class="built_in">max</span>) &#123;</span><br><span class="line">            <span class="built_in">max</span> = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//小的一组</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span> = nums[sep];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=sep+<span class="number">1</span>; j&lt;count<span class="number">-1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j]&lt;<span class="built_in">min</span>) &#123;</span><br><span class="line">            <span class="built_in">min</span> = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//与middle进行对比</span></span><br><span class="line">    <span class="keyword">if</span> (i == count-i<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (middle&gt;<span class="built_in">max</span>) &#123;</span><br><span class="line">            <span class="built_in">max</span> = middle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (middle&lt;<span class="built_in">min</span>) &#123;</span><br><span class="line">            <span class="built_in">min</span> = middle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"max = %d, min = %d"</span>, <span class="built_in">max</span>, <span class="built_in">min</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（4）在 Java 中如何从给定数组中删除多重复制?</p>
<p>（5）大数相加(今日头条)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串求和</span><br></pre></td></tr></table></figure>

<h3 id="1-1-3-链表"><a href="#1-1-3-链表" class="headerlink" title="1.1.3 链表"></a>1.1.3 链表</h3><p>（1）那查询第一个跟倒数第二个呢？（这就不一样了，第一个直接给了头结点，倒数第二个需要从倒数第一个开始查询，走两步） （腾讯）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">倒数第二个节点：</span><br><span class="line">1、如果是双向链表的话直接返回从尾节点开始的第二个节点</span><br><span class="line">2、如果是普通链表，需要两个指针，一前一后，前面的那个到尾节点，返回后面的那个节点</span><br></pre></td></tr></table></figure>
<p>（2）arrayList 底层原理 （滴滴 字节跳动）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- ArrayList底层是数组，默认大小是10，默认值是空</span><br><span class="line">- 实现List接口的动态数组，容量大小为 capacity，默认的容量大小 10，会自动扩容</span><br><span class="line">- 可包含空元素 null</span><br><span class="line">- size, isEmpty, get, set, iterator, and listIterator 等操作的复杂度为 O(1)，</span><br><span class="line">The add operation runs in amortized constanttime, </span><br><span class="line">that is, adding n elements requires O(n) time，其它操作为线性时间</span><br><span class="line">- 非线程安全，多线程环境下必须在外部增加同步限制，</span><br><span class="line">或者使用包装对象 List list &#x3D; Collections.synchronizedList(new ArrayList(...));</span><br><span class="line">- 快速失败：在使用迭代器时，调用迭代器的添加、修改、删除方法，</span><br><span class="line">将抛出 ConcurrentModificationException 异常，</span><br><span class="line">但是快速失败行为不是硬证的，只是尽最大努力</span><br></pre></td></tr></table></figure>
<p>（3）如何在一次遍历中找到单个链表的中值?（中国平安）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">中值指中间位置的值？</span><br><span class="line"></span><br><span class="line">快慢指针，快指针一次走两步，慢指针一次走一步</span><br><span class="line"></span><br><span class="line">如果是中间大小的值，需要用插入排序了</span><br></pre></td></tr></table></figure>

<p>（4）如何证明给定的链表是否包含循环?如何找到循环的头节点? （优酷）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">快慢指针，快指针每次走两步，慢指针每次走一步，快慢指针相遇时，说明有环</span><br><span class="line"></span><br><span class="line">当快慢指针相遇时，从头节点出发一个慢指针，当新的慢指针与旧的慢指针相遇时，说明时循环的头节点</span><br></pre></td></tr></table></figure>

<p>（5）两个有交叉的单链表，求交叉点 （华为）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">p1-&gt;A-&gt;B</span><br><span class="line">p2-&gt;B-&gt;A</span><br><span class="line">当两个指针相遇时便是交叉点</span><br></pre></td></tr></table></figure>
<p>（6）如何得到单链表的长度? 360</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">快慢指针O(n&#x2F;2)</span><br></pre></td></tr></table></figure>

<p>（7）如何在不使用递归的情况下逆转单链表? （小米/美团）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">维护一个dummy节点</span><br></pre></td></tr></table></figure>

<p>（8）怎么判断链表有环？ （滴滴）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">快慢三指针</span><br></pre></td></tr></table></figure>

<h3 id="1-1-4-队列-amp-堆栈"><a href="#1-1-4-队列-amp-堆栈" class="headerlink" title="1.1.4 队列&amp;堆栈"></a>1.1.4 队列&amp;堆栈</h3><p>（1）如何使用栈实现队列的功能？(广州荔枝 FM)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">两个栈可以实现一个队列</span><br><span class="line"></span><br><span class="line">1、入栈时，往A栈里面添加元素</span><br><span class="line"></span><br><span class="line">2、出栈时，把A栈里面的元素pop并push到B，从B出栈，while(B)不为空，一直从B出栈，</span><br><span class="line">否则把A栈里面的元素pop并push到B。</span><br></pre></td></tr></table></figure>

<p>（2）两个栈实现一个队列 （蘑菇街）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答案如上</span><br></pre></td></tr></table></figure>
<p>（3）两个队列实现一个栈 （腾讯）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 添加元素时默认往queue2中offer()，并将queue1中的所有元素poll()并offer到queue2中去，交换queue1和queue2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 出栈时，从queue1中poll，因为queue1中的所有元素都是按照栈中的元素排好了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue1;</span><br><span class="line">    Queue&lt;Integer&gt; queue2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue1 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        queue2 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        queue2.offer(x);</span><br><span class="line">        <span class="keyword">while</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">            queue2.offer(queue1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; temp = queue1;</span><br><span class="line">        queue1 = queue2;</span><br><span class="line">        queue2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（4）对比一下队列和栈，以及它们底部实现 （腾讯）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">队列和栈都可以用链表实现，队列只可以从头部出队，尾部入队，栈只可以从尾部操作，入栈和出栈操作都是在尾部进行的。</span><br><span class="line"></span><br><span class="line">在Java中一般使用linkedList作为栈和队列的实现</span><br></pre></td></tr></table></figure>
<h3 id="1-1-5-二叉树"><a href="#1-1-5-二叉树" class="headerlink" title="1.1.5 二叉树"></a>1.1.5 二叉树</h3><p>（1）如何在给定的二叉树中执行先序遍历?（百度）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">先序遍历是：根，左，右 </span><br><span class="line">递归:输出根节点的值，遍历左子树，遍历右子树</span><br></pre></td></tr></table></figure>
<p>（2）如何实现后序遍历算法? （百度）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">后序遍历是：左，右，根</span><br><span class="line">递归：遍历左子树，遍历右子树，输出根节点的值</span><br></pre></td></tr></table></figure>

<p>（3）如何在给定数组中执行二分法搜索? （苏宁）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果有序，直接进行二分</span><br><span class="line">如果无序，需要先进行排序，再进行二分</span><br></pre></td></tr></table></figure>

<p>（4）已知前序遍历为 {1,2,4,7,3,5,6,8}，中序遍历为 {4,7,2,1,5,3,8,6}，它的二叉树是怎么样的？ 58</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">再中序遍历中没有重复数字时：</span><br><span class="line">使用MashMap存储中序遍历的值和index的关系</span><br><span class="line"></span><br><span class="line">根据前序遍历找到根节点，根据该根节点找到中序遍历中该节点的index，通过index计算左子树中元素的数量和右子树中元素的数量（可以进一步的找到左子树的根节点的位置和右子树的根节点的位置），递归的建立树。</span><br></pre></td></tr></table></figure>

<p>（5）输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构。 （爱奇艺）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">递归： </span><br><span class="line">A的当前节点是否与B的当前节点相同，</span><br><span class="line"></span><br><span class="line">如果相同，那么比较A的左子树和B的右子树</span><br><span class="line"></span><br><span class="line">如果不同，比较A的左子树与B，比较A的右子树与B</span><br></pre></td></tr></table></figure>
<p>（6）请实现两个函数，分别用来序列化二叉树和反序列化二叉树。 （YY）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前序遍历二叉树，空节点使用#号代替，遍历完成后遍历序列中元素的数量和完全二叉树的遍历的数量是相同的</span><br><span class="line"></span><br><span class="line">还原二叉树时，使用前序构建方法构建二叉树</span><br></pre></td></tr></table></figure>
<p>（7）平衡二叉树和红黑树的区别？（字节跳动）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AVL树时带有平衡条件的二叉查找树，一般时用平衡因子差值判断是否平衡并通过旋转来实现平衡，左右子树树高差值不超过1，和红黑树比，ALVL树是严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差的绝对值不超过1）.不管我们是执行插入炒作还是删除炒作，只有不满足上述条件就要通过旋转来保持平衡，旋转是非常耗时的，由此我们可以知道AVL树适合用于插入删除较少，而查询较多的情况。</span><br><span class="line"></span><br><span class="line">由于维护这种搞得平衡所付出的代价比从中获得的效益还大，故而实际的应用不多，更多的是用追求局部而不是非常严格整体平衡的红黑树。当然，如果应用场景中队插入删除不频繁，只是对查找的要求较高，那么AVL还是优于红黑树。</span><br><span class="line"></span><br><span class="line">一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树（由于是弱平衡，可以看到，在相同的节点情况下，AVL树的高度低于红黑树），相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，我们就用红黑树。</span><br><span class="line"></span><br><span class="line">版权声明：本文为CSDN博主「Charles_yy」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;u010899985&#x2F;article&#x2F;details&#x2F;80981053</span><br></pre></td></tr></table></figure>
<p>（8）什么是平衡二叉树，它有什么特征 （美团）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AVL树是带有平衡条件的二叉查找树，一般是用平衡因子差值判断是否平衡并通过旋转来实现平衡，左右子树树高不超过1，</span><br><span class="line"></span><br><span class="line">和红黑树相比，AVL树是严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差的绝对值不超过1）。</span><br><span class="line"></span><br><span class="line">不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡，而旋转是非常耗时的，</span><br><span class="line"></span><br><span class="line">由此我们可以知道AVL树适合用于插入与删除次数比较少，但查找多的情况</span><br><span class="line"></span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「Charles_yy」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;u010899985&#x2F;article&#x2F;details&#x2F;80981053</span><br></pre></td></tr></table></figure>
<p>（9）B 树，B+树</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">B树又叫做B-树</span><br><span class="line"></span><br><span class="line">B树也称B-树,它是一颗多路平衡查找树。B树的定义。</span><br><span class="line"></span><br><span class="line">每个节点最多有m-1个关键字（可以存有的键值对）。</span><br><span class="line">根节点最少可以只有1个关键字。</span><br><span class="line">非根节点至少有m&#x2F;2个关键字。</span><br><span class="line">每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。</span><br><span class="line">所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。</span><br><span class="line">每个节点都存有索引和数据，也就是对应的key和value。</span><br><span class="line">所以，根节点的关键字数量范围：1 &lt;&#x3D; k &lt;&#x3D; m-1，非根节点的关键字数量范围：m&#x2F;2 &lt;&#x3D; k &lt;&#x3D; m-1。</span><br><span class="line"></span><br><span class="line">B+树</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">B+树其实和B树是非常相似的，我们首先看看**相同点**。</span><br><span class="line"></span><br><span class="line">- 根节点至少一个元素</span><br><span class="line">- 非根节点元素范围：m&#x2F;2 &lt;&#x3D; k &lt;&#x3D; m-1</span><br><span class="line"></span><br><span class="line">**不同点**。</span><br><span class="line"></span><br><span class="line">- B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。</span><br><span class="line">- 内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。</span><br><span class="line">- 每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。</span><br><span class="line">- 父节点存有右孩子的第一个元素的索引。</span><br></pre></td></tr></table></figure>

<h3 id="1-1-6-HashMap"><a href="#1-1-6-HashMap" class="headerlink" title="1.1.6 HashMap"></a>1.1.6 HashMap</h3><p>（1）HashMap 的底层原理是什么？线程安全么？ （百度 美团）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap在JDK1.8之前使用数组和链表实现</span><br><span class="line">在JDK1.8之后使用数组、链表和红黑树实现</span><br><span class="line"></span><br><span class="line">HashMap不是线程安全的</span><br></pre></td></tr></table></figure>
<p>（2）HashMap 中 put 是如何实现的？ （滴滴）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">（1）计算key的hash值；</span><br><span class="line"></span><br><span class="line">（2）如果桶（数组）数量为0，则初始化桶；</span><br><span class="line"></span><br><span class="line">（3）如果key所在的桶没有元素，则直接插入；</span><br><span class="line"></span><br><span class="line">（4）如果key所在的桶中的第一个元素的key与待插入的key相同，说明找到了元素，转后续流程（9）处理；</span><br><span class="line"></span><br><span class="line">（5）如果第一个元素是树节点，则调用树节点的putTreeVal()寻找元素或插入树节点；</span><br><span class="line"></span><br><span class="line">（6）如果不是以上三种情况，则遍历桶对应的链表查找key是否存在于链表中；</span><br><span class="line"></span><br><span class="line">（7）如果找到了对应key的元素，则转后续流程（9）处理；</span><br><span class="line"></span><br><span class="line">（8）如果没找到对应key的元素，则在链表最后插入一个新节点并判断是否需要树化；</span><br><span class="line"></span><br><span class="line">（9）如果找到了对应key的元素，则判断是否需要替换旧值，并直接返回旧值；</span><br><span class="line"></span><br><span class="line">（10）如果插入了元素，则数量加1并判断是否需要扩容；</span><br></pre></td></tr></table></figure>
<p>（3）谈一下 hashMap 中什么时候需要进行扩容，扩容 resize()又是如何实现的？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">插入元素时，如果当前的数量大于Threshold时，需要对其进行扩容，threshold的计算是当前哈希表的大小*loadFactor</span><br><span class="line"></span><br><span class="line">（1）如果使用是默认构造方法，则第一次插入元素时初始化为默认值，容量为16，扩容门槛为12；</span><br><span class="line"></span><br><span class="line">（2）如果使用的是非默认构造方法，则第一次插入元素时初始化容量等于扩容门槛，扩容门槛在构造方法里等于传入容量向上最近的2的n次方；</span><br><span class="line"></span><br><span class="line">（3）如果旧容量大于0，则新容量等于旧容量的2倍，但不超过最大容量2的30次方，新扩容门槛为旧扩容门槛的2倍；</span><br><span class="line"></span><br><span class="line">（4）创建一个新容量的桶；</span><br><span class="line"></span><br><span class="line">（5）搬移元素，原链表分化成两个链表(原红黑树分成两棵树)，低位链表存储在原来桶的位置，高位链表搬移到原来桶的位置加旧容量的位置；</span><br></pre></td></tr></table></figure>

<p>（4）什么是哈希碰撞？怎么解决? （滴滴 美团）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">哈希碰撞的意思是计算得到的Hash值相同，需要放到同一个bucket中</span><br><span class="line"></span><br><span class="line">链表法和开放地址法。链表法就是将相同hash值的对象组织成一个链表放在hash值对应的槽位；开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位。java.util.HashMap采用的链表法的方式，链表是单向链表。</span><br></pre></td></tr></table></figure>

<p>（5）HashMap 和 HashTable 的区别 （小米）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.安全性</span><br><span class="line">Hashtable是线程安全，HashMap是非线程安全。HashMap的性能会高于Hashtable，我们平时使用时若无特殊需求建议使用HashMap，在多线程环境下若使用HashMap需要使用Collections.synchronizedMap()方法来获取一个线程安全的集合（Collections.synchronizedMap()实现原理是Collections定义了一个SynchronizedMap的内部类，这个类实现了Map接口，在调用方法时使用synchronized来保证线程同步</span><br><span class="line">2.是否可以使用null作为key</span><br><span class="line">HashMap可以使用null作为key，不过建议还是尽量避免这样使用。HashMap以null作为key时，总是存储在table数组的第一个节点上。而Hashtable则不允许null作为key</span><br><span class="line">3.继承了什么，实现了什么</span><br><span class="line">HashMap继承了AbstractMap，HashTable继承Dictionary抽象类，两者均实现Map接口</span><br><span class="line">4.默认容量及如何扩容</span><br><span class="line">HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75。HashMap扩容时是当前容量翻倍即:capacity  2，Hashtable扩容时是容量翻倍+1即:capacity  (2+1)</span><br><span class="line">6.底层实现</span><br><span class="line">HashMap和Hashtable的底层实现都是数组+链表结构实现</span><br><span class="line">7.计算hash的方法不同</span><br><span class="line">Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取模</span><br><span class="line"></span><br><span class="line">8.扩容和默认大小不同</span><br><span class="line">可以看到HashTable默认的初始大小为11，之后每次扩充为原来的2n+1。HashMap默认的初始化大小为16，之后每次扩充为原来的2倍。</span><br><span class="line"></span><br><span class="line">作者：淼淼之森</span><br><span class="line">链接：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;6844903925460500487</span><br><span class="line">来源：掘金</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p>（6）HashMap 中什么时候需要进行扩容，扩容 resize()是如何实现的？ （滴滴）</p>
<p>（7）hashmap concurrenthashmap 原理 （美团）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（8）arraylist 和 hashmap 的区别，为什么取数快？（字节跳动）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ArrayList和HashMap的底层实现不一样</span><br><span class="line"></span><br><span class="line">ArrayList的底层实现是数组，而HashMap的底层实现是数组+链表+红黑树（JDK1.8）</span><br><span class="line"></span><br><span class="line">从数据结构上来说，两者的数据结构不一样，分别是数组和哈希表</span><br><span class="line">还有各种参数不同，ArrayList的默认大小是10，扩容是1.5倍，</span><br><span class="line">hashMap的默认大小是16，扩容是两倍</span><br><span class="line"></span><br><span class="line">ArrayList的取数快是因为在存储时是数组，连续存储，数组的访问时间复杂度是O(1)</span><br><span class="line"></span><br><span class="line">HashMap 的取数快是因为使用了hash算法定位桶的index，并且桶是使用数组存储的，此外还是使用了红黑树加速查询（在有哈希冲突的时候）</span><br></pre></td></tr></table></figure>
<h3 id="1-1-7图"><a href="#1-1-7图" class="headerlink" title="1.1.7图"></a>1.1.7图</h3><p>（1）旋转输出矩阵</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">行列转换</span><br><span class="line">列转换</span><br></pre></td></tr></table></figure>
<p>（2）给定一个矩阵 int matrixA[m][n]，每行每列都是增序的，实现一个算法去寻找矩阵中的某个元素 element. 搜狗</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从最右上角遍历</span><br><span class="line">每次删除一行或者一列</span><br></pre></td></tr></table></figure>
<h3 id="1-1-8排序算法有哪些？"><a href="#1-1-8排序算法有哪些？" class="headerlink" title="1.1.8排序算法有哪些？"></a>1.1.8排序算法有哪些？</h3><p>（1）top-k 排序(堆排序，位图法) （美团）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallestK(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        randomizedSelected(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">int</span>[] vec = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            vec[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">randomizedSelected</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pos = randomizedPartition(arr, l, r);</span><br><span class="line">        <span class="keyword">int</span> num = pos - l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == num) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; num) &#123;</span><br><span class="line">            randomizedSelected(arr, l, pos - <span class="number">1</span>, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            randomizedSelected(arr, pos + <span class="number">1</span>, r, k - num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于随机的划分</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">randomizedPartition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="keyword">new</span> Random().nextInt(r - l + <span class="number">1</span>) + l;</span><br><span class="line">        swap(nums, r, i);</span><br><span class="line">        <span class="keyword">return</span> partition(nums, l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[r];</span><br><span class="line">        <span class="keyword">int</span> i = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt;= r - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt;= pivot) &#123;</span><br><span class="line">                i = i + <span class="number">1</span>;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/smallest-k-lcci/solution/zui-xiao-kge-shu-by-leetcode-solution-o5eg/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p>（2）冒泡排序的手写 （华捷艾米）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j]&gt;nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">            swap(nums,j,j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）堆排序算法的手写 （华捷艾米）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> heapSize=nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=heapSiez/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        maxHeapify(nums,i,heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> i,<span class="keyword">int</span> heapSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">2</span>*i+<span class="number">1</span>,r=<span class="number">2</span>*i+<span class="number">2</span>,largest=i;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;heapSize&amp;&amp;nums[largest]&lt;nums[l])largets=l;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;heapSize&amp;&amp;nums[largest]&lt;nums[r])largest=r;</span><br><span class="line">    <span class="keyword">if</span>(largest!=i)&#123;</span><br><span class="line">        swap(nums,i,largest);</span><br><span class="line">        maxHeapify(nums,largest,heapSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> index1,<span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=nums[index1];</span><br><span class="line">    nums[index1]=nums[index2];</span><br><span class="line">    nums[index2]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（4）椭圆形场地有两个赛道，可以同时提供两匹马比赛，两匹马比赛后，可以获知两匹马中跑的快的那匹马，但是没有计时工具。问题，如何最优的算法(比赛次数最少)，获知 10 匹马中速度最快的三匹马 （阿里）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 锦标赛排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TournamentSort</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="comment">//用node来存储竞赛排序过程中的节点，包括里面的数据和数据在数组中的ID</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> data;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _data, <span class="keyword">int</span> _id)</span></span>&#123;</span><br><span class="line">			data = _data;</span><br><span class="line">			id = _id;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Adjust</span><span class="params">(Node[] data, <span class="keyword">int</span> idx)</span></span>&#123;<span class="comment">//当去除最小元素以后，我们要调整数组</span></span><br><span class="line">		<span class="keyword">while</span>(idx != <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(idx % <span class="number">2</span> == <span class="number">1</span>)&#123;<span class="comment">//当前id是奇数，说明并列的是idx + 1, 父节点是 (idx-1)/2</span></span><br><span class="line">				<span class="keyword">if</span>(data[idx].data &lt; data[idx + <span class="number">1</span>].data)&#123;</span><br><span class="line">					data[(idx - <span class="number">1</span>)/<span class="number">2</span>] = data[idx];</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					data[(idx-<span class="number">1</span>)/<span class="number">2</span>] = data[idx + <span class="number">1</span>];</span><br><span class="line">				&#125;</span><br><span class="line">				idx = (idx - <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(data[idx-<span class="number">1</span>].data &lt; data[idx].data)&#123;</span><br><span class="line">					data[idx/<span class="number">2</span> - <span class="number">1</span>] = data[idx-<span class="number">1</span>];</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					data[idx/<span class="number">2</span> - <span class="number">1</span>] = data[idx];</span><br><span class="line">				&#125;</span><br><span class="line">				idx = (idx/<span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Sort</span><span class="params">(<span class="keyword">int</span>[] data)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> nNodes = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> nTreeSize;</span><br><span class="line">		<span class="keyword">while</span>(nNodes &lt; data.length)&#123;</span><br><span class="line">			nNodes *= <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		nTreeSize = <span class="number">2</span> * nNodes - <span class="number">1</span>;<span class="comment">//竞赛树节点的个数, nNode算出来是为了做成满二叉树</span></span><br><span class="line">		</span><br><span class="line">		Node[] nodes = <span class="keyword">new</span> Node[nTreeSize];<span class="comment">//竞赛树用数组存储</span></span><br><span class="line">		<span class="comment">//initialize the data</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> i, j;</span><br><span class="line">		<span class="keyword">int</span> idx;</span><br><span class="line">		<span class="keyword">for</span>( i = nNodes - <span class="number">1</span>; i &lt; nTreeSize; i++) &#123;<span class="comment">//初始化竞赛树数据</span></span><br><span class="line">			idx = i - (nNodes - <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(idx &lt; data.length)&#123;</span><br><span class="line">				nodes[i] = <span class="keyword">new</span> Node(data[idx], i);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			    nodes[i] = <span class="keyword">new</span> Node(Integer.MAX_VALUE, -<span class="number">1</span>);<span class="comment">//对于补充的数据，我们初始化成最大。</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>( i = nNodes - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">			nodes[i] = <span class="keyword">new</span> Node();</span><br><span class="line">			<span class="keyword">if</span>(nodes[i * <span class="number">2</span> + <span class="number">1</span>].data &lt; nodes[i * <span class="number">2</span> + <span class="number">2</span>].data)&#123;</span><br><span class="line">				nodes[i] = nodes[i*<span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				nodes[i] = nodes[i*<span class="number">2</span> + <span class="number">2</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//the real sorting procedure</span></span><br><span class="line">		<span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; data.length; i++)&#123;<span class="comment">//实际排序的过程</span></span><br><span class="line">			data[i] = nodes[<span class="number">0</span>].data;<span class="comment">//取出最小的</span></span><br><span class="line">			nodes[nodes[<span class="number">0</span>].id].data = Integer.MAX_VALUE;</span><br><span class="line">			Adjust(nodes, nodes[<span class="number">0</span>].id);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（5）输入一个整型无序数组，对堆排序的方法使得数组有序 （阿里）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（6）如何使用快速排序算法对整数数组进行排序? （CVTE）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-1-9-查找算法"><a href="#1-1-9-查找算法" class="headerlink" title="1.1.9 查找算法"></a>1.1.9 查找算法</h3><p>（1）有序数组的二分查找算法 （百度）</p>
<h3 id="1-1-10-串"><a href="#1-1-10-串" class="headerlink" title="1.1.10 串"></a>1.1.10 串</h3><p>（1）给定一个字符串，请你找出其中不含有重复字符的 最长子串的长度。 （字节跳动）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">滑动窗口，遇到重复字符时，收缩左窗口</span><br></pre></td></tr></table></figure>
<p>（2）给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举回文中心字符串</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = i / <span class="number">2</span>, r = i / <span class="number">2</span> + i % <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; n &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class="line">                --l;</span><br><span class="line">                ++r;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-1-11-请写出以下算法的时间复杂度"><a href="#1-1-11-请写出以下算法的时间复杂度" class="headerlink" title="1.1.11 请写出以下算法的时间复杂度"></a>1.1.11 请写出以下算法的时间复杂度</h3><p>冒泡排序法 插入排序法 堆排序法 二叉树排序法</p>
<h3 id="1-1-12-其他算法"><a href="#1-1-12-其他算法" class="headerlink" title="1.1.12 其他算法"></a>1.1.12 其他算法</h3><p>（1）常用的对称加密算法，有什么同？ （字节跳动）</p>
<p>（2）如何在无序（有负数）的数组中查找是否存在和为 target 的两个数组合，twoSum(); （字节）</p>
<h2 id="1-2-Java-基础"><a href="#1-2-Java-基础" class="headerlink" title="1.2 Java 基础"></a>1.2 Java 基础</h2><p>（1）什么情况下会发生栈内存溢出？</p>
<p>（2）如果让你写一段栈溢出的代码你会什么写，一个栈大概有多大，为什么？每个线程都有这样大小的一个栈吗？ （美团）</p>
<p>（3）JVM 中一次完整的GC流程是怎样的，对象如何晋升到老年代？</p>
<p>（4）介绍下 GC 回收机制与分代回收策略。</p>
<p>（5）Java 中有几种引用关系，它们的区别是什么？</p>
<p>（6）GC 收集算法有哪些？它们的特点是什么？</p>
<p>（7）如何判断一个对象是否被回收，有哪些 GC 算法，实际虚拟机使用最多的是什么 GC 算法？（美团）</p>
<p>（8）Jvm 内存 结构说一下。 a.描述 JVM 内存模型。（东方头条）</p>
<p>（9）JVM DVM ART 的区别（360）</p>
<p>（10）描述 GC 机制。Class 会不会回收？用不到的 Class 怎么回收？(东方头条)</p>
<p>（11）StackOverFlow 与 OOM 的区别？分别发生在什么时候，JVM 栈中存储的是什么，堆存储的是什么？（美团）</p>
<p>（12）Java 虚拟机和 Dalvik 虚拟机的区别？</p>
<p>（13）请描述 new 一个对象的流程。</p>
<p>（14）Java 对象会不会分配到栈中？</p>
<p>（15）String， Stringbuffer， StringBuilder 的区别是什么？（东方头条）a.String StringBuffer StringBuilder 在进行字符串操作时的效率；这里主要考察 String 在内存中是如何创建的。（字节跳动）</p>
<p>（16）String 为什么是不可变的？（字节跳动）a.String为什么设计成final的？</p>
<p>（17）final 、finally、finalize 区别。</p>
<p>（18）抽象类和接口的区别。</p>
<p>（19）重载和重写的区别 （京东）</p>
<p>（20）什么是值传递和引用传递，Java 是值传递还是引用传递？</p>
<p>（21）String s = new String(“”);创建了几个对象?</p>
<p>（22）java 里 equals和== 区别。</p>
<p>（23）try-catch-finally，try 里有 return，finally 还执行么？</p>
<p>（24）Excption 与 Error 区别。</p>
<p>（25）Static class 与 non static class 的区别。</p>
<p>（26）PathClassLoader 与 DexClassLoader 的区别是什么？</p>
<p>（27）什么是双亲委托机制，为什么需要双亲委托机制？</p>
<p>（28）描述 JVM 类加载过程。</p>
<p>（29）动态代理是什么？如何实现？</p>
<p>（30）动态代理的方法怎么初始化的？（字节跳动）</p>
<p>（31）CGLIB 动态代理（字节跳动）</p>
<p>（32）说说反射的应用场景，哪些框架，原理是什么？</p>
<p>（33）Java 泛型的特点与优缺点，泛型擦除是怎么回事？</p>
<p>（34）List 能否转为 List。</p>
<p>（35）泛型 super 和 extends 的区别。a.说法 2：Java 的泛型，&lt;? super T&gt; 和 &lt;? extends T&gt; 的区别。</p>
<p>（36）为什么 IO 是耗时操作？</p>
<h2 id="1-3-并发编程"><a href="#1-3-并发编程" class="headerlink" title="1.3 并发编程"></a>1.3 并发编程</h2><p>（1）假如只有一个 cpu，单核，多线程还有用吗 ？（美团）</p>
<p>（2）sychronied 修饰普通方法和静态方法的区别？什么是可见性?</p>
<p>（3）锁分哪几类？</p>
<p>（4）CAS 无锁编程的原理。（字节跳动）</p>
<p>（5）ReentrantLock 的实现原理。</p>
<p>（6）AQS 原理 （小米 京东）</p>
<p>（7）Synchronized 的原理以及与 ReentrantLock 的区别。（360）</p>
<p>（8）Synchronized 在 JDK1.8 之后做了哪些优化 （京东）</p>
<p>（9）Synchronized static 与非 static 锁的区别和范围（小米）</p>
<p>（10）volatile 关键字干了什么？（什么叫指令重排） （字节跳动）</p>
<p>（11）volatile 能否保证线程安全？在 DCL 上的作用是什么？</p>
<p>（12）volatile 和 synchronize 有什么区别？（B站 小米 京东）</p>
<p>（13）两个线程用不同的对象，怎么样？（字节跳动）</p>
<p>（14）什么是守护线程？你是如何退出一个线程的？</p>
<p>（15）sleep 、wait、yield 的区别，wait 的线程如何唤醒它？（东方头条、字节跳动）</p>
<p>（16）sleep 是可中断的么？（小米）</p>
<p>（17）实现非阻塞式生产者消费者（字节跳动）</p>
<p>（18）如何开启一个线程，开启大量线程会有什么问题，如何优化？（美团）</p>
<p>（19）线程生命周期。</p>
<p>（20）ThreadLocal 是什么？</p>
<p>（21）AyncTask 的原理。</p>
<p>（22）AsyncTask 中的任务是串行的还是并行的？</p>
<p>（23）线程池管理线程原理。</p>
<p>（24）线程池的相关参数，有哪些类型的线程池，线程池任务如何调度，任务队列只是先进先出的队列吗，任务有优先级怎么办，知道优先级反转吗？ (美团)</p>
<p>（25）有三个线程 T1，T2，T3，怎么确保它们按顺序执行？</p>
<p>（26）Android 中操作多线程的方式有哪些？</p>
<p>（27）怎样获取当前线程是否是主线程 （字节跳动）</p>
<p>（28）HandlerThread 是什么？</p>
<p>（29）线程间如何通信？</p>
<p>（30）RxJava 线程切换原理，RxJava1 和 RxJava2 的区别有哪些？</p>
<h2 id="1-4-网络编程"><a href="#1-4-网络编程" class="headerlink" title="1.4 网络编程"></a>1.4 网络编程</h2><p>（1）描述 TCP 三次握手与四次挥手的过程与意义。</p>
<p>a.TCP 的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？</p>
<p>b.三次握手为什么不是两次一次 五次六次（美团）</p>
<p>（2）TCP 与 UDP 的区别是什么？（腾讯）</p>
<p>（3）Http 与 Https 的关系是什么？</p>
<p>（4）SSL 握手的过程。</p>
<p>（5）Http 的 post 与 get 请求的区别是什么？</p>
<p>（6）输入一个 URL 到浏览器发生了什么？(美团)</p>
<h1 id="hashMap"><a href="#hashMap" class="headerlink" title="hashMap"></a>hashMap</h1><p><a href="https://blog.csdn.net/qq_37989738/article/details/107756260" target="_blank" rel="noopener">部分问题答案</a></p>
<ol>
<li><p>说说你对hash算法的理解</p>
<p>追问：hash算法任意长度的输入 转化为了 固定长度的输出，会不会有问题呢？</p>
<p>追问：hash冲突能避免么？</p>
</li>
<li><p>你认为好的hash算法，应该考虑点有哪些呢？</p>
</li>
<li><p>HashMap中存储数据的结构是什么样的呢？</p>
</li>
<li><p>创建HashMap时，不指定散列表数组长度，初始长度是多少呢？<br>追问：散列表是new HashMap() 时创建的么？</p>
</li>
<li><p>默认负载因子是多少呢，并且这个负载因子有什么作用？</p>
</li>
<li><p>链表转化为红黑树，需要达到什么条件呢？</p>
</li>
<li><p>Node对象内部的hash字段，这个hash值是key对象的hashcode()返回值么？</p>
<p>追问：这个hash值是怎么得到呢？</p>
<p>追问：hash字段为什么采用高低位异或？</p>
</li>
<li><p>HashMap put 写数据的具体流程，尽可能的详细点！</p>
</li>
<li><p>红黑树的写入操作，是怎么找到父节点的，找父节点流程？</p>
</li>
<li><p>TreeNode数据结构，简单说下。</p>
</li>
<li><p>红黑树的原则有哪些呢？</p>
</li>
<li><p>JDK8 hashmap为什么引入红黑树？解决什么问题？</p>
<p>追问：为什么hash冲突后性能变低了？【送分题】</p>
</li>
<li><p>hashmap 什么情况下会触发扩容呢？</p>
<p>追问：触发扩容后，会扩容多大呢？算法是什么？</p>
<p>追问：为什么采用位移运算，不是直接*2？</p>
</li>
<li><p>hashmap扩容后，老表的数据怎么迁移到扩容后的表的呢？</p>
</li>
<li><p>hashmap扩容后，迁移数据发现该slot是颗红黑树，怎么处理呢？</p>
</li>
</ol>
<!-- # 二、Android 体系
（1）Acitvity 的生命周期是什么样的？a. Acitvity 的生命周期，如何摧毁一个 Activity? (美团)
（2）Activity 的 4 大启动模式，与开发中需要注意的问题，如 onNewIntent() 的调用；a. Activity 的启动模式，区别 （美团）b. singleInstance 如果不指定栈名，是怎么分配的？（字节跳动）
（3）Intent 显示跳转与隐式跳转，如何使用？（美团）
（4）Activity A 跳转 B，B 跳转 C，A 不能直接跳转到 C，A如何传递消息给 C？(美团)
（5）Activity 如何保存状态的？
（6）请描诉 Activity 的启动流程，从点击图标开始。(B站)a. APP 是怎么启动的？b. 启动一个Activity的流程分析
（7）Service 的生命周期是什么样的？a. Service 两种生命周期以及区别
（8）你会在什么情况下使用 Service？
（9）startServer 和 bindServier 的区别？(美团)
（10）Service 和 Thread 的区别？
（11）IntentService 与 Service 的区别？
（12）ContentProvider 如何自定义与使用场景是什么？
（13）BroadcastReciver 的静态注册与动态注册的区别？
（14）广播的分类与工作原理
（15）可以再 onReceive 中开启线程么，会有什么问题？
（16）什么是有序广播？
（17）Application、Activity、Service中context 的区别？能否启动一个 activity、dialog?
（18）Fragment 的生命周期？ （美团）
（19）Fragment 的构造函数为啥不让传参？（B站）
（20）Fragment add 与 replace 的区别，分别对 Fragment 的生命周期影响（美团）

三、View System
（1）View 绘制流程与自定义 View 注意点。（东方头条、美团）
Android 中的每一个UI控件都是集成自 View，然后这些 View 都具有相同的绘制流程，必须经过 measure，layout 和 draw。view 的绘制流程是在 Window 添加过程中，ViewRootImpl 类的 setView 方法开始的
（2）在 onResume 中可以测量宽高么
（3）事件分发机制是什么过程？（东方头条）
（4）冲突怎么解决？（东方头条）
（5）View 分发反向制约的方法？（字节跳动）
（6）自定义 Behavior，NestScroll，NestChild。（东方头条）
（7）View.inflater 过程与异步 inflater（东方头条）
（8）inflater 为什么比自定义 View 慢？（东方头条）
（9）onTouchListener onTouchEvent onClick 的执行顺序。（58 京东）
（10）怎么拦截事件 onTouchEvent 如果返回 false onClick 还会执行么？（58 京东）
（11）事件的分发机制，责任链模式的优缺点 （美团）
（12）动画的分类以及区别（车和家）
（13）属性动画与普通的动画有什么区别？（车和家）
（14）插值器 估值器的区别（车和家）
（15）RecyclerView 与 ListView 的对比，缓存策略，优缺点。（美团）
（16）WebView 如何做资源缓存？（字节跳动）
（17）WebView 和 JS 交互的几种方式与拦截方法。（字节跳动）
（18）自定义 view 与 viewgroup 的区别
（19）View 的绘制原理
（20）View 中 onTouch，onTouchEvent 和 onClick 的执行顺序
（21）View 的滑动方式
（22）invalidate() 和 postInvalicate() 区别
（23）View 的绘制流程是从 Activity 的哪个生命周期方法开始执行的
（24）Activity，Window，View 三者的联系和区别
（25）如何实现 Activity 窗口快速变暗
（26）ListView 卡顿的原因以及优化策略
（27）ViewHolder 为什么要被声明成静态内部类
（28）Android 中的动画有哪些? 动画占用大量内存，如何优化
（29）自定义 View 执行 invalidate()方法，为什么有时候不会回调 onDraw()
（30）DecorView， ViewRootImpl，View 之间的关系，ViewGroup.add()会多添加一个 ViewrootImpl 吗
（31）如何通过WindowManager添加Window(代码实现)？
（32）为什么Dialog不能用Application的Context？
（33）WindowMangerService中token到底是什么？有什么区别
（34）RecyclerView 是什么？如何使用？如何返回不一样的 Item
（35) RecyclerView 的回收复用机制
（36) 如何给 ListView & RecyclerView加上拉刷新 & 下拉加载更多机制
（37) 如何对 ListView & RecycleView 进行局部刷新的？
（38) ScrollView 下嵌套一个 RecycleView 通常会出现什么问题？
（39) 一个 ListView 或者一个 RecyclerView 在显示新闻数据的时候，出现图片错位，可能的原因有哪些 & 如何解决？
（40）Requestlayout，onlayout，onDraw，DrawChild 区别与联系
（41) 如何优化自定义 View
（42) Android 属性动画实现原理，补间动画实现原理

四、Android FrameWork
Android 中多进程通信的方式有哪些？a.进程通信你用过哪些？原理是什么？（字节跳动、小米）
描述下 Binder 机制原理？（东方头条）
Binder 线程池的工作过程是什么样？（东方头条）
Handler 怎么进行线程通信，原理是什么？（东方头条）
Handler 如果没有消息处理是阻塞的还是非阻塞的？（字节跳动、小米）
handler.post(Runnable) runnable 是如何执行的？（字节跳动、小米）
handler 的 Callback 和 handlemessage 都存在，但 callback 返回 true handleMessage 还会执行么？（字节跳动、小米）
Handler 的 sendMessage 和 postDelay 的区别？（字节跳动）
IdleHandler 是什么？怎么使用，能解决什么问题？
为什么 Looper.loop 不阻塞主线程？a.Looper 无限循环为啥没有 ANR（B站）
Looper 如何在子线程中创建？（字节跳动、小米）
Looper、handler、线程间的关系。例如一个线程可以有几个 Looper 可以对应几个 Handler？（字节跳动、小米）
如何更新 UI，为什么子线程不能更新 UI？(美团)
ThreadLocal 的原理，以及在 Looper 是如何应用的？（字节跳动、小米）
Android 有哪些存储数据的方式？
SharedPreference 原理，commit 与 apply 的区别是什么？使用时需要有哪些注意？
如何判断一个 APP 在前台还是后台？
如何做应用保活？
一张图片 100x100 在内存中的大小？（字节跳动）
Intent的 原理，作用，可以传递哪些类型的参数?
如果需要在 Activity 间传递大量的数据怎么办？
打开多个页面，如何实现一键退出?
LiveData 的生命周期如何监听的?(B站)
五、性能优化专题
App 稳定性优化
App 启动速度优化
App 内存优化
App 绘制优化
App 瘦身
网络优化
App 电量优化
安卓的安全优化
为什么 WebView 加载会慢呢？
如何优化自定义 View
FC(Force Close)什么时候会出现？
Java 多线程引发的性能问题，怎么解决？
TraceView 的实现原理，分析数据误差来源。
是否使用过 SysTrace，原理的了解？
mmap + native 日志优化？
六、三方源码理解
Glide ：加载、缓存、LRU 算法 (如何自己设计一个大图加载框架) （LRUCache 原理）
EventBus
LeakCanary
ARouter
插件化（不同插件化机制原理与流派，优缺点。局限性）
热修复
RXJava （RxJava 的线程切换原理）
Retrofit （Retrofit 在 OkHttp 上做了哪些封装？动态代理和静态代理的区别，是怎么实现的）
OkHttp -->
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">作者：木木</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;circle&#x2F;discuss&#x2F;5szs6p&#x2F;</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-02-06</span><i class="fa fa-tag"></i><span class="leancloud_visitors"></span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2021/02/06/问题记录/,Vector,问题记录,;" target="_blank" rel="noopener"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2021/02/06/%E7%BB%9F%E8%AE%A1%E4%BD%9C%E6%88%98%E5%8D%95%E4%BD%8D%E6%95%B0/" title="统计作战单位数">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2021/02/06/%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E7%82%B9%E6%95%B0/" title="可获得的最大点数">下一篇</a></li></ul></div><script src="/js/visitors.js"></script><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@latest/dist/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:false|| false, 
  app_id:'',
  app_key:'',
  placeholder:'念念不忘，必有回响...',
  path: window.location.pathname,
  serverURLs: '',
  visitor:true,
  recordIP:true,
  avatar:'mp'
})</script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/js/baidu-tongji.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":200,"height":350},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body></html>