<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Vector"><title>问题记录 · Vector</title><meta name="description" content="MathJax.Hub.Config({
tex2jax: {
  inlineMath: [['$','$'], ['\\(','\\)']],
  processEscapes: true
  }
});





部分原文一、Java 基础相关1.1 数据结构与算法1.1.1 常用的数据结构有"><meta name="keywords" content="Vector的小窝"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Vector</a></h3><div class="description"><p>没人扶你的时候，自己要站直，路还长，背影要美！</p></div></div></div><ul class="social-links"><li><a href="https://github.com/IMVector" target="_blank" rel="noopener"><i class="fa fa-github"></i></a></li><li><a href="mailto:1769326712@qq.com"><i class="fa fa-envelope"></i></a></li><li><a href="http://sighttp.qq.com/authd?IDKEY=" target="_blank" rel="noopener"><i class="fa fa-qq"></i></a></li><li><a href="https://zhihu.com/people/" target="_blank" rel="noopener"><i class="fa fa-mortar-board"></i></a></li></ul><div class="footer"><div class="p"> <span>© 2017 - 2020 </span><i class="fa fa-star"></i><span> Vector</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><a href="https://github.com/mrcore/hexo-theme-Anatole-Core" target="_blank">Anatole-Core.  </a><span> &</span><a href="https://github.com/IMVector/blog_vector" target="_blank">Vector.  </a><a href="http://www.beian.miit.gov.cn/" target="_blank">&nbsp;粤ICP备15011643号</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">标签</a></li><li><a href="/about">关于</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>问题记录</a></h3></div><div class="post-content"><!--将该代码放入博客模板的head中即可-->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
  inlineMath: [['$','$'], ['\\(','\\)']],
  processEscapes: true
  }
});
</script>
<!--latex数学显示公式-->
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


<h1 id="部分原文"><a href="#部分原文" class="headerlink" title="部分原文"></a><a href="https://leetcode-cn.com/circle/discuss/5szs6p/" target="_blank" rel="noopener">部分原文</a></h1><h1 id="一、Java-基础相关"><a href="#一、Java-基础相关" class="headerlink" title="一、Java 基础相关"></a>一、Java 基础相关</h1><h2 id="1-1-数据结构与算法"><a href="#1-1-数据结构与算法" class="headerlink" title="1.1 数据结构与算法"></a>1.1 数据结构与算法</h2><h3 id="1-1-1-常用的数据结构有哪些"><a href="#1-1-1-常用的数据结构有哪些" class="headerlink" title="1.1.1 常用的数据结构有哪些?"></a>1.1.1 常用的数据结构有哪些?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组、链表、树（二叉树、二叉搜索树、红黑树）、图（有向图，无向图）、栈、队列、散列表</span><br></pre></td></tr></table></figure>
<h3 id="1-1-2-数组"><a href="#1-1-2-数组" class="headerlink" title="1.1.2 数组"></a>1.1.2 数组</h3><p>（1）如何在一个 1 到 100 的整数数组中找到丢失的数字?<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">二分查找O（logn）</span><br><span class="line">哈希表O（n）</span><br></pre></td></tr></table></figure></p>
<p>（2）如何在给定的整数数组中找到重复的数字? （小米）<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">哈希表</span><br><span class="line">原地哈希表</span><br></pre></td></tr></table></figure></p>
<p>（3）如何在未排序整数数组中找到最大值和最小值?（字节跳动）</p>
<ul>
<li>使用两个值记录最大值和最小值, 每次取出两个值,先进行比较,小的与最小值比较,大的与最大值比较 , 比较次数: 1.5∗N</li>
<li>将相邻的数进行比较,大的放在偶数位置,小的放在奇数位置, 最后奇数位置比较和偶数位置对应比较,得到最大值和最小值,比较次数: $1.5∗N$ ;</li>
</ul>
<p><a href="https://www.cnblogs.com/hugochen1024/p/12570824.html" target="_blank" rel="noopener">東木:无序数组中求最大值和最小值的最少比较次数</a></p>
<p><a href="https://www.jianshu.com/p/96fa355e1faf" target="_blank" rel="noopener">作者：逃之不桃链接：来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</a><br>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路是类似于快速排序的分组方式，对数组从两头进行分组，</span></span><br><span class="line"><span class="comment">// 即第0个元素与第n-1个元素进行对比，大的放a组，小的放b组；</span></span><br><span class="line"><span class="comment">// 然后第一个与n-2进行对比........直到两边序号重合，比较次数为n/2，</span></span><br><span class="line"><span class="comment">// 这时，最大的数肯定在a组里，最小的数肯定在b组。</span></span><br><span class="line"><span class="comment">// 然后再在a组里寻找最大值，再在b组里寻找最小值，分别都是n/2次比较，</span></span><br><span class="line"><span class="comment">// 一共使用3/2n次比较就搞定啦。</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">findMaxandMinNumber</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分组</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; (count - i - <span class="number">1</span>); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]&lt;nums[count<span class="number">-1</span>-i]) &#123;</span><br><span class="line">            <span class="comment">//交换位置</span></span><br><span class="line">            <span class="keyword">int</span> tem = nums[i];</span><br><span class="line">            nums[i] = nums[count-i<span class="number">-1</span>];</span><br><span class="line">            nums[count-i<span class="number">-1</span>] = tem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sep = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> middle = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == count-i<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">//奇数</span></span><br><span class="line">        sep = count/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        middle = nums[count/<span class="number">2</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//偶数</span></span><br><span class="line">        sep = count/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//大的一组</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;count/<span class="number">2</span><span class="number">-1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j]&gt;<span class="built_in">max</span>) &#123;</span><br><span class="line">            <span class="built_in">max</span> = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//小的一组</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span> = nums[sep];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=sep+<span class="number">1</span>; j&lt;count<span class="number">-1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j]&lt;<span class="built_in">min</span>) &#123;</span><br><span class="line">            <span class="built_in">min</span> = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//与middle进行对比</span></span><br><span class="line">    <span class="keyword">if</span> (i == count-i<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (middle&gt;<span class="built_in">max</span>) &#123;</span><br><span class="line">            <span class="built_in">max</span> = middle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (middle&lt;<span class="built_in">min</span>) &#123;</span><br><span class="line">            <span class="built_in">min</span> = middle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"max = %d, min = %d"</span>, <span class="built_in">max</span>, <span class="built_in">min</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（4）在 Java 中如何从给定数组中删除多重复制?</p>
<p>（5）大数相加(今日头条)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串求和</span><br></pre></td></tr></table></figure>

<h3 id="1-1-3-链表"><a href="#1-1-3-链表" class="headerlink" title="1.1.3 链表"></a>1.1.3 链表</h3><p>（1）那查询第一个跟倒数第二个呢？（这就不一样了，第一个直接给了头结点，倒数第二个需要从倒数第一个开始查询，走两步） （腾讯）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">倒数第二个节点：</span><br><span class="line">1、如果是双向链表的话直接返回从尾节点开始的第二个节点</span><br><span class="line">2、如果是普通链表，需要两个指针，一前一后，前面的那个到尾节点，返回后面的那个节点</span><br></pre></td></tr></table></figure>
<p>（2）arrayList 底层原理 （滴滴 字节跳动）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- ArrayList底层是数组，默认大小是10，默认值是空</span><br><span class="line">- 实现List接口的动态数组，容量大小为 capacity，默认的容量大小 10，会自动扩容</span><br><span class="line">- 可包含空元素 null</span><br><span class="line">- size, isEmpty, get, set, iterator, and listIterator 等操作的复杂度为 O(1)，</span><br><span class="line">The add operation runs in amortized constanttime, </span><br><span class="line">that is, adding n elements requires O(n) time，其它操作为线性时间</span><br><span class="line">- 非线程安全，多线程环境下必须在外部增加同步限制，</span><br><span class="line">或者使用包装对象 List list &#x3D; Collections.synchronizedList(new ArrayList(...));</span><br><span class="line">- 快速失败：在使用迭代器时，调用迭代器的添加、修改、删除方法，</span><br><span class="line">将抛出 ConcurrentModificationException 异常，</span><br><span class="line">但是快速失败行为不是硬证的，只是尽最大努力</span><br></pre></td></tr></table></figure>
<p>（3）如何在一次遍历中找到单个链表的中值?（中国平安）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">中值指中间位置的值？</span><br><span class="line"></span><br><span class="line">快慢指针，快指针一次走两步，慢指针一次走一步</span><br><span class="line"></span><br><span class="line">如果是中间大小的值，需要用插入排序了</span><br></pre></td></tr></table></figure>

<p>（4）如何证明给定的链表是否包含循环?如何找到循环的头节点? （优酷）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">快慢指针，快指针每次走两步，慢指针每次走一步，快慢指针相遇时，说明有环</span><br><span class="line"></span><br><span class="line">当快慢指针相遇时，从头节点出发一个慢指针，当新的慢指针与旧的慢指针相遇时，说明时循环的头节点</span><br></pre></td></tr></table></figure>

<p>（5）两个有交叉的单链表，求交叉点 （华为）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">p1-&gt;A-&gt;B</span><br><span class="line">p2-&gt;B-&gt;A</span><br><span class="line">当两个指针相遇时便是交叉点</span><br></pre></td></tr></table></figure>
<p>（6）如何得到单链表的长度? 360</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">快慢指针O(n&#x2F;2)</span><br></pre></td></tr></table></figure>

<p>（7）如何在不使用递归的情况下逆转单链表? （小米/美团）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">维护一个dummy节点</span><br></pre></td></tr></table></figure>

<p>（8）怎么判断链表有环？ （滴滴）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">快慢三指针</span><br></pre></td></tr></table></figure>

<h3 id="1-1-4-队列-amp-堆栈"><a href="#1-1-4-队列-amp-堆栈" class="headerlink" title="1.1.4 队列&amp;堆栈"></a>1.1.4 队列&amp;堆栈</h3><p>（1）如何使用栈实现队列的功能？(广州荔枝 FM)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">两个栈可以实现一个队列</span><br><span class="line"></span><br><span class="line">1、入栈时，往A栈里面添加元素</span><br><span class="line"></span><br><span class="line">2、出栈时，把A栈里面的元素pop并push到B，从B出栈，while(B)不为空，一直从B出栈，</span><br><span class="line">否则把A栈里面的元素pop并push到B。</span><br></pre></td></tr></table></figure>

<p>（2）两个栈实现一个队列 （蘑菇街）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答案如上</span><br></pre></td></tr></table></figure>
<p>（3）两个队列实现一个栈 （腾讯）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 添加元素时默认往queue2中offer()，并将queue1中的所有元素poll()并offer到queue2中去，交换queue1和queue2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 出栈时，从queue1中poll，因为queue1中的所有元素都是按照栈中的元素排好了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue1;</span><br><span class="line">    Queue&lt;Integer&gt; queue2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue1 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        queue2 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        queue2.offer(x);</span><br><span class="line">        <span class="keyword">while</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">            queue2.offer(queue1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; temp = queue1;</span><br><span class="line">        queue1 = queue2;</span><br><span class="line">        queue2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（4）对比一下队列和栈，以及它们底部实现 （腾讯）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">队列和栈都可以用链表实现，队列只可以从头部出队，尾部入队，栈只可以从尾部操作，入栈和出栈操作都是在尾部进行的。</span><br><span class="line"></span><br><span class="line">在Java中一般使用linkedList作为栈和队列的实现</span><br></pre></td></tr></table></figure>
<h3 id="1-1-5-二叉树"><a href="#1-1-5-二叉树" class="headerlink" title="1.1.5 二叉树"></a>1.1.5 二叉树</h3><p>（1）如何在给定的二叉树中执行先序遍历?（百度）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">先序遍历是：根，左，右 </span><br><span class="line">递归:输出根节点的值，遍历左子树，遍历右子树</span><br></pre></td></tr></table></figure>
<p>（2）如何实现后序遍历算法? （百度）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">后序遍历是：左，右，根</span><br><span class="line">递归：遍历左子树，遍历右子树，输出根节点的值</span><br></pre></td></tr></table></figure>

<p>（3）如何在给定数组中执行二分法搜索? （苏宁）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果有序，直接进行二分</span><br><span class="line">如果无序，需要先进行排序，再进行二分</span><br></pre></td></tr></table></figure>

<p>（4）已知前序遍历为 {1,2,4,7,3,5,6,8}，中序遍历为 {4,7,2,1,5,3,8,6}，它的二叉树是怎么样的？ 58</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">再中序遍历中没有重复数字时：</span><br><span class="line">使用MashMap存储中序遍历的值和index的关系</span><br><span class="line"></span><br><span class="line">根据前序遍历找到根节点，根据该根节点找到中序遍历中该节点的index，通过index计算左子树中元素的数量和右子树中元素的数量（可以进一步的找到左子树的根节点的位置和右子树的根节点的位置），递归的建立树。</span><br></pre></td></tr></table></figure>

<p>（5）输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构。 （爱奇艺）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">递归： </span><br><span class="line">A的当前节点是否与B的当前节点相同，</span><br><span class="line"></span><br><span class="line">如果相同，那么比较A的左子树和B的右子树</span><br><span class="line"></span><br><span class="line">如果不同，比较A的左子树与B，比较A的右子树与B</span><br></pre></td></tr></table></figure>
<p>（6）请实现两个函数，分别用来序列化二叉树和反序列化二叉树。 （YY）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前序遍历二叉树，空节点使用#号代替，遍历完成后遍历序列中元素的数量和完全二叉树的遍历的数量是相同的</span><br><span class="line"></span><br><span class="line">还原二叉树时，使用前序构建方法构建二叉树</span><br></pre></td></tr></table></figure>
<p>（7）平衡二叉树和红黑树的区别？（字节跳动）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AVL树时带有平衡条件的二叉查找树，一般时用平衡因子差值判断是否平衡并通过旋转来实现平衡，左右子树树高差值不超过1，和红黑树比，ALVL树是严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差的绝对值不超过1）.不管我们是执行插入炒作还是删除炒作，只有不满足上述条件就要通过旋转来保持平衡，旋转是非常耗时的，由此我们可以知道AVL树适合用于插入删除较少，而查询较多的情况。</span><br><span class="line"></span><br><span class="line">由于维护这种搞得平衡所付出的代价比从中获得的效益还大，故而实际的应用不多，更多的是用追求局部而不是非常严格整体平衡的红黑树。当然，如果应用场景中队插入删除不频繁，只是对查找的要求较高，那么AVL还是优于红黑树。</span><br><span class="line"></span><br><span class="line">一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树（由于是弱平衡，可以看到，在相同的节点情况下，AVL树的高度低于红黑树），相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，我们就用红黑树。</span><br><span class="line"></span><br><span class="line">版权声明：本文为CSDN博主「Charles_yy」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;u010899985&#x2F;article&#x2F;details&#x2F;80981053</span><br></pre></td></tr></table></figure>
<p>（8）什么是平衡二叉树，它有什么特征 （美团）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AVL树是带有平衡条件的二叉查找树，一般是用平衡因子差值判断是否平衡并通过旋转来实现平衡，左右子树树高不超过1，</span><br><span class="line"></span><br><span class="line">和红黑树相比，AVL树是严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差的绝对值不超过1）。</span><br><span class="line"></span><br><span class="line">不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡，而旋转是非常耗时的，</span><br><span class="line"></span><br><span class="line">由此我们可以知道AVL树适合用于插入与删除次数比较少，但查找多的情况</span><br><span class="line"></span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「Charles_yy」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;u010899985&#x2F;article&#x2F;details&#x2F;80981053</span><br></pre></td></tr></table></figure>
<p>（9）B 树，B+树</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">B树又叫做B-树</span><br><span class="line"></span><br><span class="line">B树也称B-树,它是一颗多路平衡查找树。B树的定义。</span><br><span class="line"></span><br><span class="line">每个节点最多有m-1个关键字（可以存有的键值对）。</span><br><span class="line">根节点最少可以只有1个关键字。</span><br><span class="line">非根节点至少有m&#x2F;2个关键字。</span><br><span class="line">每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。</span><br><span class="line">所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。</span><br><span class="line">每个节点都存有索引和数据，也就是对应的key和value。</span><br><span class="line">所以，根节点的关键字数量范围：1 &lt;&#x3D; k &lt;&#x3D; m-1，非根节点的关键字数量范围：m&#x2F;2 &lt;&#x3D; k &lt;&#x3D; m-1。</span><br><span class="line"></span><br><span class="line">B+树</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">B+树其实和B树是非常相似的，我们首先看看**相同点**。</span><br><span class="line"></span><br><span class="line">- 根节点至少一个元素</span><br><span class="line">- 非根节点元素范围：m&#x2F;2 &lt;&#x3D; k &lt;&#x3D; m-1</span><br><span class="line"></span><br><span class="line">**不同点**。</span><br><span class="line"></span><br><span class="line">- B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。</span><br><span class="line">- 内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。</span><br><span class="line">- 每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。</span><br><span class="line">- 父节点存有右孩子的第一个元素的索引。</span><br></pre></td></tr></table></figure>

<h3 id="1-1-6-HashMap"><a href="#1-1-6-HashMap" class="headerlink" title="1.1.6 HashMap"></a>1.1.6 HashMap</h3><p>（1）HashMap 的底层原理是什么？线程安全么？ （百度 美团）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap在JDK1.8之前使用数组和链表实现</span><br><span class="line">在JDK1.8之后使用数组、链表和红黑树实现</span><br><span class="line"></span><br><span class="line">HashMap不是线程安全的</span><br></pre></td></tr></table></figure>
<p>（2）HashMap 中 put 是如何实现的？ （滴滴）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">（1）计算key的hash值；</span><br><span class="line"></span><br><span class="line">（2）如果桶（数组）数量为0，则初始化桶；</span><br><span class="line"></span><br><span class="line">（3）如果key所在的桶没有元素，则直接插入；</span><br><span class="line"></span><br><span class="line">（4）如果key所在的桶中的第一个元素的key与待插入的key相同，说明找到了元素，转后续流程（9）处理；</span><br><span class="line"></span><br><span class="line">（5）如果第一个元素是树节点，则调用树节点的putTreeVal()寻找元素或插入树节点；</span><br><span class="line"></span><br><span class="line">（6）如果不是以上三种情况，则遍历桶对应的链表查找key是否存在于链表中；</span><br><span class="line"></span><br><span class="line">（7）如果找到了对应key的元素，则转后续流程（9）处理；</span><br><span class="line"></span><br><span class="line">（8）如果没找到对应key的元素，则在链表最后插入一个新节点并判断是否需要树化；</span><br><span class="line"></span><br><span class="line">（9）如果找到了对应key的元素，则判断是否需要替换旧值，并直接返回旧值；</span><br><span class="line"></span><br><span class="line">（10）如果插入了元素，则数量加1并判断是否需要扩容；</span><br></pre></td></tr></table></figure>
<p>（3）谈一下 hashMap 中什么时候需要进行扩容，扩容 resize()又是如何实现的？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">插入元素时，如果当前的数量大于Threshold时，需要对其进行扩容，threshold的计算是当前哈希表的大小*loadFactor</span><br><span class="line"></span><br><span class="line">（1）如果使用是默认构造方法，则第一次插入元素时初始化为默认值，容量为16，扩容门槛为12；</span><br><span class="line"></span><br><span class="line">（2）如果使用的是非默认构造方法，则第一次插入元素时初始化容量等于扩容门槛，扩容门槛在构造方法里等于传入容量向上最近的2的n次方；</span><br><span class="line"></span><br><span class="line">（3）如果旧容量大于0，则新容量等于旧容量的2倍，但不超过最大容量2的30次方，新扩容门槛为旧扩容门槛的2倍；</span><br><span class="line"></span><br><span class="line">（4）创建一个新容量的桶；</span><br><span class="line"></span><br><span class="line">（5）搬移元素，原链表分化成两个链表(原红黑树分成两棵树)，低位链表存储在原来桶的位置，高位链表搬移到原来桶的位置加旧容量的位置；</span><br></pre></td></tr></table></figure>

<p>（4）什么是哈希碰撞？怎么解决? （滴滴 美团）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">哈希碰撞的意思是计算得到的Hash值相同，需要放到同一个bucket中</span><br><span class="line"></span><br><span class="line">链表法和开放地址法。链表法就是将相同hash值的对象组织成一个链表放在hash值对应的槽位；开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位。java.util.HashMap采用的链表法的方式，链表是单向链表。</span><br></pre></td></tr></table></figure>

<p>（5）HashMap 和 HashTable 的区别 （小米）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.安全性</span><br><span class="line">Hashtable是线程安全，HashMap是非线程安全。HashMap的性能会高于Hashtable，我们平时使用时若无特殊需求建议使用HashMap，在多线程环境下若使用HashMap需要使用Collections.synchronizedMap()方法来获取一个线程安全的集合（Collections.synchronizedMap()实现原理是Collections定义了一个SynchronizedMap的内部类，这个类实现了Map接口，在调用方法时使用synchronized来保证线程同步</span><br><span class="line">2.是否可以使用null作为key</span><br><span class="line">HashMap可以使用null作为key，不过建议还是尽量避免这样使用。HashMap以null作为key时，总是存储在table数组的第一个节点上。而Hashtable则不允许null作为key</span><br><span class="line">3.继承了什么，实现了什么</span><br><span class="line">HashMap继承了AbstractMap，HashTable继承Dictionary抽象类，两者均实现Map接口</span><br><span class="line">4.默认容量及如何扩容</span><br><span class="line">HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75。HashMap扩容时是当前容量翻倍即:capacity  2，Hashtable扩容时是容量翻倍+1即:capacity  (2+1)</span><br><span class="line">6.底层实现</span><br><span class="line">HashMap和Hashtable的底层实现都是数组+链表结构实现</span><br><span class="line">7.计算hash的方法不同</span><br><span class="line">Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取模</span><br><span class="line"></span><br><span class="line">8.扩容和默认大小不同</span><br><span class="line">可以看到HashTable默认的初始大小为11，之后每次扩充为原来的2n+1。HashMap默认的初始化大小为16，之后每次扩充为原来的2倍。</span><br><span class="line"></span><br><span class="line">作者：淼淼之森</span><br><span class="line">链接：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;6844903925460500487</span><br><span class="line">来源：掘金</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p>（6）HashMap 中什么时候需要进行扩容，扩容 resize()是如何实现的？ （滴滴）</p>
<p>（7）hashmap concurrenthashmap 原理 （美团）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（8）arraylist 和 hashmap 的区别，为什么取数快？（字节跳动）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ArrayList和HashMap的底层实现不一样</span><br><span class="line"></span><br><span class="line">ArrayList的底层实现是数组，而HashMap的底层实现是数组+链表+红黑树（JDK1.8）</span><br><span class="line"></span><br><span class="line">从数据结构上来说，两者的数据结构不一样，分别是数组和哈希表</span><br><span class="line">还有各种参数不同，ArrayList的默认大小是10，扩容是1.5倍，</span><br><span class="line">hashMap的默认大小是16，扩容是两倍</span><br><span class="line"></span><br><span class="line">ArrayList的取数快是因为在存储时是数组，连续存储，数组的访问时间复杂度是O(1)</span><br><span class="line"></span><br><span class="line">HashMap 的取数快是因为使用了hash算法定位桶的index，并且桶是使用数组存储的，此外还是使用了红黑树加速查询（在有哈希冲突的时候）</span><br></pre></td></tr></table></figure>
<h3 id="1-1-7图"><a href="#1-1-7图" class="headerlink" title="1.1.7图"></a>1.1.7图</h3><p>（1）旋转输出矩阵</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">行列转换</span><br><span class="line">列转换</span><br></pre></td></tr></table></figure>
<p>（2）给定一个矩阵 int matrixA[m][n]，每行每列都是增序的，实现一个算法去寻找矩阵中的某个元素 element. 搜狗</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从最右上角遍历</span><br><span class="line">每次删除一行或者一列</span><br></pre></td></tr></table></figure>
<h3 id="1-1-8排序算法有哪些？"><a href="#1-1-8排序算法有哪些？" class="headerlink" title="1.1.8排序算法有哪些？"></a>1.1.8排序算法有哪些？</h3><p>（1）top-k 排序(堆排序，位图法) （美团）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallestK(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        randomizedSelected(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">int</span>[] vec = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            vec[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">randomizedSelected</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pos = randomizedPartition(arr, l, r);</span><br><span class="line">        <span class="keyword">int</span> num = pos - l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == num) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; num) &#123;</span><br><span class="line">            randomizedSelected(arr, l, pos - <span class="number">1</span>, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            randomizedSelected(arr, pos + <span class="number">1</span>, r, k - num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于随机的划分</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">randomizedPartition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="keyword">new</span> Random().nextInt(r - l + <span class="number">1</span>) + l;</span><br><span class="line">        swap(nums, r, i);</span><br><span class="line">        <span class="keyword">return</span> partition(nums, l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[r];</span><br><span class="line">        <span class="keyword">int</span> i = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt;= r - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt;= pivot) &#123;</span><br><span class="line">                i = i + <span class="number">1</span>;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/smallest-k-lcci/solution/zui-xiao-kge-shu-by-leetcode-solution-o5eg/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p>（2）冒泡排序的手写 （华捷艾米）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j]&gt;nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">            swap(nums,j,j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）堆排序算法的手写 （华捷艾米）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> heapSize=nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=heapSiez/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        maxHeapify(nums,i,heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> i,<span class="keyword">int</span> heapSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">2</span>*i+<span class="number">1</span>,r=<span class="number">2</span>*i+<span class="number">2</span>,largest=i;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;heapSize&amp;&amp;nums[largest]&lt;nums[l])largets=l;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;heapSize&amp;&amp;nums[largest]&lt;nums[r])largest=r;</span><br><span class="line">    <span class="keyword">if</span>(largest!=i)&#123;</span><br><span class="line">        swap(nums,i,largest);</span><br><span class="line">        maxHeapify(nums,largest,heapSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> index1,<span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=nums[index1];</span><br><span class="line">    nums[index1]=nums[index2];</span><br><span class="line">    nums[index2]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（4）椭圆形场地有两个赛道，可以同时提供两匹马比赛，两匹马比赛后，可以获知两匹马中跑的快的那匹马，但是没有计时工具。问题，如何最优的算法(比赛次数最少)，获知 10 匹马中速度最快的三匹马 （阿里）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 锦标赛排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TournamentSort</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="comment">//用node来存储竞赛排序过程中的节点，包括里面的数据和数据在数组中的ID</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> data;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _data, <span class="keyword">int</span> _id)</span></span>&#123;</span><br><span class="line">			data = _data;</span><br><span class="line">			id = _id;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Adjust</span><span class="params">(Node[] data, <span class="keyword">int</span> idx)</span></span>&#123;<span class="comment">//当去除最小元素以后，我们要调整数组</span></span><br><span class="line">		<span class="keyword">while</span>(idx != <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(idx % <span class="number">2</span> == <span class="number">1</span>)&#123;<span class="comment">//当前id是奇数，说明并列的是idx + 1, 父节点是 (idx-1)/2</span></span><br><span class="line">				<span class="keyword">if</span>(data[idx].data &lt; data[idx + <span class="number">1</span>].data)&#123;</span><br><span class="line">					data[(idx - <span class="number">1</span>)/<span class="number">2</span>] = data[idx];</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					data[(idx-<span class="number">1</span>)/<span class="number">2</span>] = data[idx + <span class="number">1</span>];</span><br><span class="line">				&#125;</span><br><span class="line">				idx = (idx - <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(data[idx-<span class="number">1</span>].data &lt; data[idx].data)&#123;</span><br><span class="line">					data[idx/<span class="number">2</span> - <span class="number">1</span>] = data[idx-<span class="number">1</span>];</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					data[idx/<span class="number">2</span> - <span class="number">1</span>] = data[idx];</span><br><span class="line">				&#125;</span><br><span class="line">				idx = (idx/<span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Sort</span><span class="params">(<span class="keyword">int</span>[] data)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> nNodes = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> nTreeSize;</span><br><span class="line">		<span class="keyword">while</span>(nNodes &lt; data.length)&#123;</span><br><span class="line">			nNodes *= <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		nTreeSize = <span class="number">2</span> * nNodes - <span class="number">1</span>;<span class="comment">//竞赛树节点的个数, nNode算出来是为了做成满二叉树</span></span><br><span class="line">		</span><br><span class="line">		Node[] nodes = <span class="keyword">new</span> Node[nTreeSize];<span class="comment">//竞赛树用数组存储</span></span><br><span class="line">		<span class="comment">//initialize the data</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> i, j;</span><br><span class="line">		<span class="keyword">int</span> idx;</span><br><span class="line">		<span class="keyword">for</span>( i = nNodes - <span class="number">1</span>; i &lt; nTreeSize; i++) &#123;<span class="comment">//初始化竞赛树数据</span></span><br><span class="line">			idx = i - (nNodes - <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(idx &lt; data.length)&#123;</span><br><span class="line">				nodes[i] = <span class="keyword">new</span> Node(data[idx], i);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			    nodes[i] = <span class="keyword">new</span> Node(Integer.MAX_VALUE, -<span class="number">1</span>);<span class="comment">//对于补充的数据，我们初始化成最大。</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>( i = nNodes - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">			nodes[i] = <span class="keyword">new</span> Node();</span><br><span class="line">			<span class="keyword">if</span>(nodes[i * <span class="number">2</span> + <span class="number">1</span>].data &lt; nodes[i * <span class="number">2</span> + <span class="number">2</span>].data)&#123;</span><br><span class="line">				nodes[i] = nodes[i*<span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				nodes[i] = nodes[i*<span class="number">2</span> + <span class="number">2</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//the real sorting procedure</span></span><br><span class="line">		<span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; data.length; i++)&#123;<span class="comment">//实际排序的过程</span></span><br><span class="line">			data[i] = nodes[<span class="number">0</span>].data;<span class="comment">//取出最小的</span></span><br><span class="line">			nodes[nodes[<span class="number">0</span>].id].data = Integer.MAX_VALUE;</span><br><span class="line">			Adjust(nodes, nodes[<span class="number">0</span>].id);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（5）输入一个整型无序数组，对堆排序的方法使得数组有序 （阿里）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（6）如何使用快速排序算法对整数数组进行排序? （CVTE）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-1-9-查找算法"><a href="#1-1-9-查找算法" class="headerlink" title="1.1.9 查找算法"></a>1.1.9 查找算法</h3><p>（1）有序数组的二分查找算法 （百度）</p>
<h3 id="1-1-10-串"><a href="#1-1-10-串" class="headerlink" title="1.1.10 串"></a>1.1.10 串</h3><p>（1）给定一个字符串，请你找出其中不含有重复字符的 最长子串的长度。 （字节跳动）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口，遇到重复字符时，收缩左窗口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            r = i;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(s.charAt(i))) &#123;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                    max = Math.max(r - l, max);</span><br><span class="line">                    <span class="keyword">if</span> (s.charAt(l) != s.charAt(i)) &#123;</span><br><span class="line">                        set.remove(s.charAt(l));</span><br><span class="line">                        l++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        l++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set.add(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(max, set.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举回文中心字符串</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> len1 = expandAroundCenter(s, i, i);</span><br><span class="line">            <span class="keyword">int</span> len2 = expandAroundCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> len = Math.max(len1, len2);</span><br><span class="line">            <span class="keyword">if</span> (len &gt; end - start) &#123;</span><br><span class="line">                start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                end = i + len / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        String ans = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">// 枚举子字符串的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; n; ++l) &#123;</span><br><span class="line">            <span class="comment">// 枚举每个字符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + l &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + l;</span><br><span class="line">                <span class="keyword">if</span> (l == <span class="number">0</span>) &#123;<span class="comment">// 也就是dp[i][j]=true 一个字符自身肯定是回文的</span></span><br><span class="line">                    dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l == <span class="number">1</span>) &#123;<span class="comment">// 相邻的两个字符是相同的那么这两个字符是回文的</span></span><br><span class="line">                    dp[i][j] = (s.charAt(i) == s.charAt(j));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// dp[i+1][j-1]其中i+1是向右移动左边界，j-1是向左移动右边界，即如果当前的相同并且靠近回文中心的也相同，那么i和j对应的也相同（需要自内而外计算）</span></span><br><span class="line">                    dp[i][j] = (s.charAt(i) == s.charAt(j) &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 其中l是枚举的区间的长度</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; l + <span class="number">1</span> &gt; ans.length()) &#123;</span><br><span class="line">                    ans = s.substring(i, i + l + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-1-11-请写出以下算法的时间复杂度"><a href="#1-1-11-请写出以下算法的时间复杂度" class="headerlink" title="1.1.11 请写出以下算法的时间复杂度"></a>1.1.11 请写出以下算法的时间复杂度</h3><p>冒泡排序法 插入排序法 堆排序法 二叉树排序法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">冒泡排序法 插入排序法   堆排序法        二叉树排序法</span><br><span class="line"> O(N*N)     O(N*N)    O(N*log(N))     O(N*log(N))</span><br></pre></td></tr></table></figure>

<h3 id="1-1-12-其他算法"><a href="#1-1-12-其他算法" class="headerlink" title="1.1.12 其他算法"></a>1.1.12 其他算法</h3><p>（1）常用的对称加密算法，有什么同？ （字节跳动）<br>| 名称  | 密钥长度                 | 运算速度 | 安全性 | 资源消耗 | 加密类型   |<br>| :—- | :———————– | :——- | :—– | :——- | :——— |<br>| DES   | 56位                     | 较快     | 低     | 中       | 对称加密   |<br>| 3DES  | 168位                    | 慢       | 中     | 高       | 对称加密   |<br>| IDEA  | 128位                    | 较慢     | 中     | 高       | 对称加密   |<br>| AES   | 128、192、256位          | 快       | 高     | 低       | 对称加密   |<br>| RSA   | 1024、2048、3072、4096位 | 慢       | 高     | 高       | 非对称加密 |<br>| DSA   | 1024、2048、3072、4096位 | 慢       | 高     | 低       | 非对称加密 |<br>| ECC   | 256                      | 快       | 高     | 低       | 非对称加密 |<br>| SHA-1 |                          | 慢       | 高     | 低       | Hash加密   |<br>| MD5   |                          | 快       | 中     | 低       | Hash加密   |</p>
<p>（2）如何在无序（有负数）的数组中查找是否存在和为 target 的两个数组合，twoSum(); （字节）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map.containsKey(target-curNum)</span><br><span class="line">使用HashMap加速，时间复杂度O(n)</span><br></pre></td></tr></table></figure>

<h2 id="1-2-Java-基础"><a href="#1-2-Java-基础" class="headerlink" title="1.2 Java 基础"></a>1.2 Java 基础</h2><p>（1）什么情况下会发生栈内存溢出？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">一、 栈溢出(StackOverflowError)</span><br><span class="line">栈是线程私有的，他的生命周期与线程相同，</span><br><span class="line">每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口灯信息。</span><br><span class="line">局部变量表又包含基本数据类型，对象引用类型（局部变量表编译器完成，运行期间不会变化）</span><br><span class="line"></span><br><span class="line">所以我们可以理解为栈溢出就是方法执行是创建的栈帧超过了栈的深度。</span><br><span class="line">那么最有可能的就是方法递归调用产生这种结果。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「LJHSkyWalker」的原创文章，</span><br><span class="line">遵循CC <span class="number">4.0</span> BY-SA版权协议，</span><br><span class="line">转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/qq_31615049/article/details/82980799</span></span><br><span class="line"></span><br><span class="line">如果Java虚拟机栈可以动态扩展，并且扩展的动作已经尝试过，</span><br><span class="line">但是无法申请到足够的内存去完成扩展，或者在新建立线程的时候没有足够的内存去创建对应的虚拟机栈，</span><br><span class="line">那么Java虚拟机将抛出一个OutOfMemory 异常。(线程启动过多)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(i++);</span><br><span class="line">		a();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		JvmTest j = <span class="keyword">new</span> JvmTest();</span><br><span class="line">		j.a();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如何解决：</span><br><span class="line"></span><br><span class="line">我们需要使用参数 -Xss 去调整JVM栈的大小</span><br></pre></td></tr></table></figure>
<p>（2）如果让你写一段栈溢出的代码你会什么写，一个栈大概有多大，为什么？每个线程都有这样大小的一个栈吗？ （美团）</p>
<p>（3）JVM 中一次完整的GC流程是怎样的，对象如何晋升到老年代？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Java堆 &#x3D; 老年代 + 新生代</span><br><span class="line">新生代 &#x3D; Eden + S0 + S1</span><br><span class="line">当 Eden 区的空间满了， Java虚拟机会触发一次 Minor GC，以收集新生代的垃圾，存活下来的对象，则会转移到 Survivor区。</span><br><span class="line">大对象（需要大量连续内存空间的Java对象，如那种很长的字符串）直接进入老年态；</span><br><span class="line">如果对象在Eden出生，并经过第一次Minor GC后仍然存活，并且被Survivor容纳的话，年龄设为1，</span><br><span class="line">每熬过一次Minor GC，年龄+1，若年龄超过一定限制（15），则被晋升到老年态。即长期存活的对象进入老年态。</span><br><span class="line">老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行Full GC，Full GC  清理整个内存堆 – 包括年轻代和年老代。</span><br><span class="line">Major GC 发生在老年代的GC，清理老年区，经常会伴随至少一次Minor GC，比Minor GC慢10倍以上。</span><br><span class="line"></span><br><span class="line">作者：捡田螺的小男孩</span><br><span class="line">链接：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;6844903895123099662</span><br><span class="line">来源：掘金</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p>（4）介绍下 GC 回收机制与分代回收策略。</p>
<p>（5）Java 中有几种引用关系，它们的区别是什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">强引用、软引用、弱引用、虚引用</span><br><span class="line">（1）强引用：在Java中最常见的就是强引用。在把一个对象赋给一个引用变量时，这个引用变量就是一个强引用。</span><br><span class="line">有强引用的对象一定为可达性状态，所以不会被垃圾回收机制回收。因此，强引用是造成Java内存泄漏（Memory Link）的主要原因。</span><br><span class="line"></span><br><span class="line">（2）软引用：软引用通过SoftReference类实现。如果一个对象只有软引用，则在系统内存空间不足时该对象将被回收。</span><br><span class="line"></span><br><span class="line">（3）弱引用：弱引用通过WeakReference类实现，如果一个对象只有弱引用，则在垃圾回收过程中一定会被回收。</span><br><span class="line"></span><br><span class="line">（4）虚引用：虚引用通过PhantomReference类实现，虚引用和引用队列联合使用，主要用于跟踪对象的垃圾回收状态。</span><br></pre></td></tr></table></figure>

<p>（6）GC 收集算法有哪些？它们的特点是什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">标记清除</span><br><span class="line"></span><br><span class="line">复制</span><br><span class="line"></span><br><span class="line">标记整理</span><br></pre></td></tr></table></figure>

<p>（7）如何判断一个对象是否被回收，有哪些 GC 算法，实际虚拟机使用最多的是什么 GC 算法？（美团）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">引用计数法（两个对象相互引用也就是循环引用）</span><br><span class="line">可达性分析（从GC root开始进行可达性分析）根搜索算法</span><br><span class="line">标记清除</span><br><span class="line">复制</span><br><span class="line">标记整理</span><br></pre></td></tr></table></figure>
<p>（8）Jvm 内存 结构说一下。 a.描述 JVM 内存模型。（东方头条）</p>
<p>（9）JVM DVM ART 的区别（360）</p>
<p>（10）描述 GC 机制。Class 会不会回收？用不到的 Class 怎么回收？(东方头条)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">方法区的垃圾收集主要回收两部分：废弃的常量和不再使用的类型。判定一个常量是否废弃相对简单，与对象类似，只要某个常量不再被引用，就会被清理。而判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了，需要同时满足下面三个条件：</span><br><span class="line"></span><br><span class="line">该类的所有实例都已经被回收，即 Java 堆中不存在该类及其任何派生子类的实例</span><br><span class="line"></span><br><span class="line">加载该类的类加载器已经被回收</span><br><span class="line"></span><br><span class="line">该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</span><br><span class="line"></span><br><span class="line">Java 虚拟机允许对满足上述三个条件的无用类进行回收，但并不是说必然被回收，仅仅是允许而已。关于是否要对类型进行回收，HotSpot 虚拟机提供了 -Xnoclassgc 参数进行控制</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「陆翎」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_30682043&#x2F;article&#x2F;details&#x2F;113051854</span><br></pre></td></tr></table></figure>
<p>（11）StackOverFlow 与 OOM 的区别？分别发生在什么时候，JVM 栈中存储的是什么，堆存储的是什么？（美团）</p>
<p>（12）Java 虚拟机和 Dalvik 虚拟机的区别？</p>
<p>（13）请描述 new 一个对象的流程。<a href="https://blog.csdn.net/SmartShylyBoy/article/details/109653745" target="_blank" rel="noopener">new 一个对象的流程</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">以person对象为例</span><br><span class="line"></span><br><span class="line">通过双亲委派机制加载类-&gt;初始化类-&gt;构建对象：首先main线程会在栈中申请一个自己的栈空间，然后调用main方法后会生成一个main方法的栈帧。</span><br><span class="line">然后执行new Person() ，这里会根据Person类元信息先确定对象的大小，向JVM堆中申请一块内存区域并构建对象，</span><br><span class="line">同时对Person对象成员变量信息并赋默认值。</span><br><span class="line">-&gt;初始化对象：然后执行对象内部生成的init方法，初始化成员变量值，</span><br><span class="line">同时执行搜集到的&#123;&#125;代码块逻辑，最后执行对象构造方法</span><br><span class="line">-&gt;引用对象：对象实例化完毕后，再把栈中的Person对象引用地址指向Person对象在堆内存中的地址。</span><br></pre></td></tr></table></figure>
<p>（14）Java 对象会不会分配到栈中？<br><a href="https://www.cnblogs.com/hollischuang/p/12501950.html" target="_blank" rel="noopener">求你了，别再说Java对象都是在堆内存上分配空间的了！</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Java编译器经过解释执行，其执行速度必然会比直接执行可执行的二进制字节码慢很多。</span><br><span class="line">为了解决这种效率问题，引入了 JIT（Just In Time ，即时编译） 技术。</span><br><span class="line"></span><br><span class="line">有了JIT技术之后，Java程序还是通过解释器进行解释执行，当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。</span><br><span class="line">在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，</span><br><span class="line">就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</span><br><span class="line"></span><br><span class="line">通过标量替换，原本的一个对象，被替换成了多个成员变量。而原本需要在堆上分配的内存，</span><br><span class="line">也就不再需要了，完全可以在本地方法栈中完成对成员变量的内存分配。</span><br></pre></td></tr></table></figure>

<p>（15）String， Stringbuffer， StringBuilder 的区别是什么？（东方头条）a.String StringBuffer StringBuilder 在进行字符串操作时的效率；这里主要考察 String 在内存中是如何创建的。（字节跳动）</p>
<p>（16）String 为什么是不可变的？（字节跳动）a.String为什么设计成final的？</p>
<p>（17）final 、finally、finalize 区别。</p>
<p>（18）抽象类和接口的区别。</p>
<p>（19）重载和重写的区别 （京东）</p>
<p>（20）什么是值传递和引用传递，Java 是值传递还是引用传递？</p>
<p>（21）String s = new String(“”);创建了几个对象?</p>
<p>（22）java 里 equals和== 区别。</p>
<p>（23）try-catch-finally，try 里有 return，finally 还执行么？</p>
<p>（24）Excption 与 Error 区别。</p>
<p>（25）Static class 与 non static class 的区别。</p>
<p>（26）PathClassLoader 与 DexClassLoader 的区别是什么？</p>
<p>（27）什么是双亲委托机制，为什么需要双亲委托机制？</p>
<p>（28）描述 JVM 类加载过程。</p>
<p>（29）动态代理是什么？如何实现？</p>
<p>（30）动态代理的方法怎么初始化的？（字节跳动）</p>
<p>（31）CGLIB 动态代理（字节跳动）</p>
<p>（32）说说反射的应用场景，哪些框架，原理是什么？</p>
<p>（33）Java 泛型的特点与优缺点，泛型擦除是怎么回事？</p>
<p>（34）List 能否转为 List。</p>
<p>（35）泛型 super 和 extends 的区别。a.说法 2：Java 的泛型，&lt;? super T&gt; 和 &lt;? extends T&gt; 的区别。</p>
<p>（36）为什么 IO 是耗时操作？</p>
<h2 id="1-3-并发编程"><a href="#1-3-并发编程" class="headerlink" title="1.3 并发编程"></a>1.3 并发编程</h2><p>（1）假如只有一个 cpu，单核，多线程还有用吗 ？（美团）</p>
<p>（2）sychronied 修饰普通方法和静态方法的区别？什么是可见性?</p>
<p>（3）锁分哪几类？</p>
<p>（4）CAS 无锁编程的原理。（字节跳动）</p>
<p>（5）ReentrantLock 的实现原理。</p>
<p>（6）AQS 原理 （小米 京东）</p>
<p>（7）Synchronized 的原理以及与 ReentrantLock 的区别。（360）</p>
<p>（8）Synchronized 在 JDK1.8 之后做了哪些优化 （京东）</p>
<p>（9）Synchronized static 与非 static 锁的区别和范围（小米）</p>
<p>（10）volatile 关键字干了什么？（什么叫指令重排） （字节跳动）</p>
<p>（11）volatile 能否保证线程安全？在 DCL 上的作用是什么？</p>
<p>（12）volatile 和 synchronize 有什么区别？（B站 小米 京东）</p>
<p>（13）两个线程用不同的对象，怎么样？（字节跳动）</p>
<p>（14）什么是守护线程？你是如何退出一个线程的？</p>
<p>（15）sleep 、wait、yield 的区别，wait 的线程如何唤醒它？（东方头条、字节跳动）</p>
<p>（16）sleep 是可中断的么？（小米）</p>
<p>（17）实现非阻塞式生产者消费者（字节跳动）</p>
<p>（18）如何开启一个线程，开启大量线程会有什么问题，如何优化？（美团）</p>
<p>（19）线程生命周期。</p>
<p>（20）ThreadLocal 是什么？</p>
<p>（21）AyncTask 的原理。</p>
<p>（22）AsyncTask 中的任务是串行的还是并行的？</p>
<p>（23）线程池管理线程原理。</p>
<p>（24）线程池的相关参数，有哪些类型的线程池，线程池任务如何调度，任务队列只是先进先出的队列吗，任务有优先级怎么办，知道优先级反转吗？ (美团)</p>
<p>（25）有三个线程 T1，T2，T3，怎么确保它们按顺序执行？</p>
<p>（26）Android 中操作多线程的方式有哪些？</p>
<p>（27）怎样获取当前线程是否是主线程 （字节跳动）</p>
<p>（28）HandlerThread 是什么？</p>
<p>（29）线程间如何通信？</p>
<p>（30）RxJava 线程切换原理，RxJava1 和 RxJava2 的区别有哪些？</p>
<h2 id="1-4-网络编程"><a href="#1-4-网络编程" class="headerlink" title="1.4 网络编程"></a>1.4 网络编程</h2><p>（1）描述 TCP 三次握手与四次挥手的过程与意义。</p>
<p>a.TCP 的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？</p>
<p>b.三次握手为什么不是两次一次 五次六次（美团）</p>
<p>（2）TCP 与 UDP 的区别是什么？（腾讯）</p>
<p>（3）Http 与 Https 的关系是什么？</p>
<p>（4）SSL 握手的过程。</p>
<p>（5）Http 的 post 与 get 请求的区别是什么？</p>
<p>（6）输入一个 URL 到浏览器发生了什么？(美团)</p>
<h1 id="hashMap"><a href="#hashMap" class="headerlink" title="hashMap"></a>hashMap</h1><p><a href="https://blog.csdn.net/qq_37989738/article/details/107756260" target="_blank" rel="noopener">部分问题答案</a></p>
<ol>
<li><p>说说你对hash算法的理解</p>
<p>追问：hash算法任意长度的输入 转化为了 固定长度的输出，会不会有问题呢？</p>
<p>追问：hash冲突能避免么？</p>
</li>
<li><p>你认为好的hash算法，应该考虑点有哪些呢？</p>
</li>
<li><p>HashMap中存储数据的结构是什么样的呢？</p>
</li>
<li><p>创建HashMap时，不指定散列表数组长度，初始长度是多少呢？<br>追问：散列表是new HashMap() 时创建的么？</p>
</li>
<li><p>默认负载因子是多少呢，并且这个负载因子有什么作用？</p>
</li>
<li><p>链表转化为红黑树，需要达到什么条件呢？</p>
</li>
<li><p>Node对象内部的hash字段，这个hash值是key对象的hashcode()返回值么？</p>
<p>追问：这个hash值是怎么得到呢？</p>
<p>追问：hash字段为什么采用高低位异或？</p>
</li>
<li><p>HashMap put 写数据的具体流程，尽可能的详细点！</p>
</li>
<li><p>红黑树的写入操作，是怎么找到父节点的，找父节点流程？</p>
</li>
<li><p>TreeNode数据结构，简单说下。</p>
</li>
<li><p>红黑树的原则有哪些呢？</p>
</li>
<li><p>JDK8 hashmap为什么引入红黑树？解决什么问题？</p>
<p>追问：为什么hash冲突后性能变低了？【送分题】</p>
</li>
<li><p>hashmap 什么情况下会触发扩容呢？</p>
<p>追问：触发扩容后，会扩容多大呢？算法是什么？</p>
<p>追问：为什么采用位移运算，不是直接*2？</p>
</li>
<li><p>hashmap扩容后，老表的数据怎么迁移到扩容后的表的呢？</p>
</li>
<li><p>hashmap扩容后，迁移数据发现该slot是颗红黑树，怎么处理呢？</p>
</li>
</ol>
<!-- # 二、Android 体系
（1）Acitvity 的生命周期是什么样的？a. Acitvity 的生命周期，如何摧毁一个 Activity? (美团)
（2）Activity 的 4 大启动模式，与开发中需要注意的问题，如 onNewIntent() 的调用；a. Activity 的启动模式，区别 （美团）b. singleInstance 如果不指定栈名，是怎么分配的？（字节跳动）
（3）Intent 显示跳转与隐式跳转，如何使用？（美团）
（4）Activity A 跳转 B，B 跳转 C，A 不能直接跳转到 C，A如何传递消息给 C？(美团)
（5）Activity 如何保存状态的？
（6）请描诉 Activity 的启动流程，从点击图标开始。(B站)a. APP 是怎么启动的？b. 启动一个Activity的流程分析
（7）Service 的生命周期是什么样的？a. Service 两种生命周期以及区别
（8）你会在什么情况下使用 Service？
（9）startServer 和 bindServier 的区别？(美团)
（10）Service 和 Thread 的区别？
（11）IntentService 与 Service 的区别？
（12）ContentProvider 如何自定义与使用场景是什么？
（13）BroadcastReciver 的静态注册与动态注册的区别？
（14）广播的分类与工作原理
（15）可以再 onReceive 中开启线程么，会有什么问题？
（16）什么是有序广播？
（17）Application、Activity、Service中context 的区别？能否启动一个 activity、dialog?
（18）Fragment 的生命周期？ （美团）
（19）Fragment 的构造函数为啥不让传参？（B站）
（20）Fragment add 与 replace 的区别，分别对 Fragment 的生命周期影响（美团）

三、View System
（1）View 绘制流程与自定义 View 注意点。（东方头条、美团）
Android 中的每一个UI控件都是集成自 View，然后这些 View 都具有相同的绘制流程，必须经过 measure，layout 和 draw。view 的绘制流程是在 Window 添加过程中，ViewRootImpl 类的 setView 方法开始的
（2）在 onResume 中可以测量宽高么
（3）事件分发机制是什么过程？（东方头条）
（4）冲突怎么解决？（东方头条）
（5）View 分发反向制约的方法？（字节跳动）
（6）自定义 Behavior，NestScroll，NestChild。（东方头条）
（7）View.inflater 过程与异步 inflater（东方头条）
（8）inflater 为什么比自定义 View 慢？（东方头条）
（9）onTouchListener onTouchEvent onClick 的执行顺序。（58 京东）
（10）怎么拦截事件 onTouchEvent 如果返回 false onClick 还会执行么？（58 京东）
（11）事件的分发机制，责任链模式的优缺点 （美团）
（12）动画的分类以及区别（车和家）
（13）属性动画与普通的动画有什么区别？（车和家）
（14）插值器 估值器的区别（车和家）
（15）RecyclerView 与 ListView 的对比，缓存策略，优缺点。（美团）
（16）WebView 如何做资源缓存？（字节跳动）
（17）WebView 和 JS 交互的几种方式与拦截方法。（字节跳动）
（18）自定义 view 与 viewgroup 的区别
（19）View 的绘制原理
（20）View 中 onTouch，onTouchEvent 和 onClick 的执行顺序
（21）View 的滑动方式
（22）invalidate() 和 postInvalicate() 区别
（23）View 的绘制流程是从 Activity 的哪个生命周期方法开始执行的
（24）Activity，Window，View 三者的联系和区别
（25）如何实现 Activity 窗口快速变暗
（26）ListView 卡顿的原因以及优化策略
（27）ViewHolder 为什么要被声明成静态内部类
（28）Android 中的动画有哪些? 动画占用大量内存，如何优化
（29）自定义 View 执行 invalidate()方法，为什么有时候不会回调 onDraw()
（30）DecorView， ViewRootImpl，View 之间的关系，ViewGroup.add()会多添加一个 ViewrootImpl 吗
（31）如何通过WindowManager添加Window(代码实现)？
（32）为什么Dialog不能用Application的Context？
（33）WindowMangerService中token到底是什么？有什么区别
（34）RecyclerView 是什么？如何使用？如何返回不一样的 Item
（35) RecyclerView 的回收复用机制
（36) 如何给 ListView & RecyclerView加上拉刷新 & 下拉加载更多机制
（37) 如何对 ListView & RecycleView 进行局部刷新的？
（38) ScrollView 下嵌套一个 RecycleView 通常会出现什么问题？
（39) 一个 ListView 或者一个 RecyclerView 在显示新闻数据的时候，出现图片错位，可能的原因有哪些 & 如何解决？
（40）Requestlayout，onlayout，onDraw，DrawChild 区别与联系
（41) 如何优化自定义 View
（42) Android 属性动画实现原理，补间动画实现原理

四、Android FrameWork
Android 中多进程通信的方式有哪些？a.进程通信你用过哪些？原理是什么？（字节跳动、小米）
描述下 Binder 机制原理？（东方头条）
Binder 线程池的工作过程是什么样？（东方头条）
Handler 怎么进行线程通信，原理是什么？（东方头条）
Handler 如果没有消息处理是阻塞的还是非阻塞的？（字节跳动、小米）
handler.post(Runnable) runnable 是如何执行的？（字节跳动、小米）
handler 的 Callback 和 handlemessage 都存在，但 callback 返回 true handleMessage 还会执行么？（字节跳动、小米）
Handler 的 sendMessage 和 postDelay 的区别？（字节跳动）
IdleHandler 是什么？怎么使用，能解决什么问题？
为什么 Looper.loop 不阻塞主线程？a.Looper 无限循环为啥没有 ANR（B站）
Looper 如何在子线程中创建？（字节跳动、小米）
Looper、handler、线程间的关系。例如一个线程可以有几个 Looper 可以对应几个 Handler？（字节跳动、小米）
如何更新 UI，为什么子线程不能更新 UI？(美团)
ThreadLocal 的原理，以及在 Looper 是如何应用的？（字节跳动、小米）
Android 有哪些存储数据的方式？
SharedPreference 原理，commit 与 apply 的区别是什么？使用时需要有哪些注意？
如何判断一个 APP 在前台还是后台？
如何做应用保活？
一张图片 100x100 在内存中的大小？（字节跳动）
Intent的 原理，作用，可以传递哪些类型的参数?
如果需要在 Activity 间传递大量的数据怎么办？
打开多个页面，如何实现一键退出?
LiveData 的生命周期如何监听的?(B站)
五、性能优化专题
App 稳定性优化
App 启动速度优化
App 内存优化
App 绘制优化
App 瘦身
网络优化
App 电量优化
安卓的安全优化
为什么 WebView 加载会慢呢？
如何优化自定义 View
FC(Force Close)什么时候会出现？
Java 多线程引发的性能问题，怎么解决？
TraceView 的实现原理，分析数据误差来源。
是否使用过 SysTrace，原理的了解？
mmap + native 日志优化？
六、三方源码理解
Glide ：加载、缓存、LRU 算法 (如何自己设计一个大图加载框架) （LRUCache 原理）
EventBus
LeakCanary
ARouter
插件化（不同插件化机制原理与流派，优缺点。局限性）
热修复
RXJava （RxJava 的线程切换原理）
Retrofit （Retrofit 在 OkHttp 上做了哪些封装？动态代理和静态代理的区别，是怎么实现的）
OkHttp -->
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">作者：木木</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;circle&#x2F;discuss&#x2F;5szs6p&#x2F;</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p><a href="https://juejin.cn/post/6844903895123099662" target="_blank" rel="noopener">以下部分原文</a></p>
<h3 id="1-什么情况下会发生栈内存溢出。"><a href="#1-什么情况下会发生栈内存溢出。" class="headerlink" title="1.什么情况下会发生栈内存溢出。"></a>1.什么情况下会发生栈内存溢出。</h3><p><strong>思路：</strong> 描述栈定义，再描述为什么会溢出，再说明一下相关配置参数，OK的话可以给面试官手写是一个栈溢出的demo。</p>
<p><strong>我的答案：</strong></p>
<ul>
<li>栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。局部变量表又包含基本数据类型，对象引用类型</li>
<li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常，方法递归调用产生这种结果。</li>
<li>如果Java虚拟机栈可以动态扩展，并且扩展的动作已经尝试过，但是无法申请到足够的内存去完成扩展，或者在新建立线程的时候没有足够的内存去创建对应的虚拟机栈，那么Java虚拟机将抛出一个OutOfMemory 异常。(线程启动过多)</li>
<li>参数 -Xss 去调整JVM栈的大小</li>
</ul>
<h3 id="2-详解JVM内存模型"><a href="#2-详解JVM内存模型" class="headerlink" title="2.详解JVM内存模型"></a>2.详解JVM内存模型</h3><p><strong>思路：</strong> 给面试官画一下JVM内存模型图，并描述每个模块的定义，作用，以及可能会存在的问题，如栈溢出等。</p>
<p><strong>我的答案：</strong></p>
<ul>
<li>JVM内存结构</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/22/16c1a426ed9ab48b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>程序计数器：当前线程所执行的字节码的行号指示器，用于记录正在执行的虚拟机字节指令地址，线程私有。</p>
<p>Java虚拟栈：存放基本数据类型、对象的引用、方法出口等，线程私有。</p>
<p>Native方法栈：和虚拟栈相似，只不过它服务于Native方法，线程私有。</p>
<p>Java堆：java内存最大的一块，所有对象实例、数组都存放在java堆，GC回收的地方，线程共享。</p>
<p>方法区：存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。（即永久带），回收目标主要是常量池的回收和类型的卸载，各线程共享</p>
<h3 id="3-JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。"><a href="#3-JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。" class="headerlink" title="3.JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。"></a>3.JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。</h3><p><strong>思路：</strong> 先讲一下JAVA堆，新生代的划分，再谈谈它们之间的转化，相互之间一些参数的配置（如： –XX:NewRatio，–XX:SurvivorRatio等），再解释为什么要这样划分，最好加一点自己的理解。</p>
<p><strong>我的答案：</strong></p>
<h4 id="1）共享内存区划分"><a href="#1）共享内存区划分" class="headerlink" title="1）共享内存区划分"></a>1）共享内存区划分</h4><ul>
<li>共享内存区 = 持久带 + 堆</li>
<li>持久带 = 方法区 + 其他</li>
<li>Java堆 = 老年代 + 新生代</li>
<li>新生代 = Eden + S0 + S1</li>
</ul>
<h4 id="2）一些参数的配置"><a href="#2）一些参数的配置" class="headerlink" title="2）一些参数的配置"></a>2）一些参数的配置</h4><ul>
<li>默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ，可以通过参数 –XX:NewRatio 配置。</li>
<li>默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定)</li>
<li>Survivor区中的对象被复制次数为15(对应虚拟机参数 -XX:+MaxTenuringThreshold)</li>
</ul>
<h4 id="3-为什么要分为Eden和Survivor-为什么要设置两个Survivor区？"><a href="#3-为什么要分为Eden和Survivor-为什么要设置两个Survivor区？" class="headerlink" title="3)为什么要分为Eden和Survivor?为什么要设置两个Survivor区？"></a>3)为什么要分为Eden和Survivor?为什么要设置两个Survivor区？</h4><ul>
<li>如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC.老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多,所以需要分为Eden和Survivor。</li>
<li>Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。</li>
<li>设置两个Survivor区最大的好处就是解决了碎片化，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）</li>
</ul>
<h3 id="4-JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代"><a href="#4-JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代" class="headerlink" title="4. JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代"></a>4. JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代</h3><p><strong>思路：</strong> 先描述一下Java堆内存划分，再解释Minor GC，Major GC，full GC，描述它们之间转化流程。</p>
<p><strong>我的答案：</strong></p>
<ul>
<li>Java堆 = 老年代 + 新生代</li>
<li>新生代 = Eden + S0 + S1</li>
<li>当 Eden 区的空间满了， Java虚拟机会触发一次 Minor GC，以收集新生代的垃圾，存活下来的对象，则会转移到 Survivor区。</li>
<li><strong>大对象</strong>（需要大量连续内存空间的Java对象，如那种很长的字符串）<strong>直接进入老年态</strong>；</li>
<li>如果对象在Eden出生，并经过第一次Minor GC后仍然存活，并且被Survivor容纳的话，年龄设为1，每熬过一次Minor GC，年龄+1，<strong>若年龄超过一定限制（15），则被晋升到老年态</strong>。即<strong>长期存活的对象进入老年态</strong>。</li>
<li>老年代满了而<strong>无法容纳更多的对象</strong>，Minor GC 之后通常就会进行Full GC，Full GC  清理整个内存堆 – <strong>包括年轻代和年老代</strong>。</li>
<li>Major GC <strong>发生在老年代的GC</strong>，<strong>清理老年区</strong>，经常会伴随至少一次Minor GC，<strong>比Minor GC慢10倍以上</strong>。</li>
</ul>
<h3 id="5-你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。"><a href="#5-你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。" class="headerlink" title="5.你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。"></a>5.你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。</h3><p><strong>思路：</strong> 一定要记住典型的垃圾收集器，尤其cms和G1，它们的原理与区别，涉及的垃圾回收算法。</p>
<p><strong>我的答案：</strong></p>
<h4 id="1）几种垃圾收集器："><a href="#1）几种垃圾收集器：" class="headerlink" title="1）几种垃圾收集器："></a>1）几种垃圾收集器：</h4><ul>
<li><strong>Serial收集器：</strong> 单线程的收集器，收集垃圾时，必须stop the world，使用复制算法。</li>
<li><strong>ParNew收集器：</strong>  Serial收集器的多线程版本，也需要stop the world，复制算法。</li>
<li><strong>Parallel Scavenge收集器：</strong> 新生代收集器，复制算法的收集器，并发的多线程收集器，目标是达到一个可控的吞吐量。如果虚拟机总共运行100分钟，其中垃圾花掉1分钟，吞吐量就是99%。</li>
<li><strong>Serial Old收集器：</strong> 是Serial收集器的老年代版本，单线程收集器，使用标记整理算法。</li>
<li><strong>Parallel Old收集器：</strong> 是Parallel Scavenge收集器的老年代版本，使用多线程，标记-整理算法。</li>
<li><strong>CMS(Concurrent Mark Sweep) 收集器：</strong> 是一种以获得最短回收停顿时间为目标的收集器，<strong>标记清除算法，运作过程：初始标记，并发标记，重新标记，并发清除</strong>，收集结束会产生大量空间碎片。</li>
<li><strong>G1收集器：</strong> 标记整理算法实现，<strong>运作流程主要包括以下：初始标记，并发标记，最终标记，筛选标记</strong>。不会产生空间碎片，可以精确地控制停顿。</li>
</ul>
<h4 id="2）CMS收集器和G1收集器的区别："><a href="#2）CMS收集器和G1收集器的区别：" class="headerlink" title="2）CMS收集器和G1收集器的区别："></a>2）CMS收集器和G1收集器的区别：</h4><ul>
<li>CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用；</li>
<li>G1收集器收集范围是老年代和新生代，不需要结合其他收集器使用；</li>
<li>CMS收集器以最小的停顿时间为目标的收集器；</li>
<li>G1收集器可预测垃圾回收的停顿时间</li>
<li>CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片</li>
<li>G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。</li>
</ul>
<h3 id="6-JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存。"><a href="#6-JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存。" class="headerlink" title="6.JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存。"></a>6.JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存。</h3><p><strong>思路：</strong>  先画出Java内存模型图，结合例子volatile ，说明什么是重排序，内存屏障，最好能给面试官写以下demo说明。</p>
<p><strong>我的答案：</strong></p>
<h4 id="1）Java内存模型图："><a href="#1）Java内存模型图：" class="headerlink" title="1）Java内存模型图："></a>1）Java内存模型图：</h4><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1c1982e3609b1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>Java内存模型规定了所有的<strong>变量都存储在主内存</strong>中，每条<strong>线程还有自己的工作内存</strong>，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，<strong>线程对变量的所有操作都必须在工作内存中</strong>进行，<strong>而不能直接读写主内存</strong>。不同的线程之间也<strong>无法直接访问对方工作内存中的变量</strong>，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</p>
<h4 id="2）指令重排序。"><a href="#2）指令重排序。" class="headerlink" title="2）指令重排序。"></a>2）指令重排序。</h4><p>在这里，先看一段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class PossibleReordering &#123;</span><br><span class="line">static int x &#x3D; 0, y &#x3D; 0;</span><br><span class="line">static int a &#x3D; 0, b &#x3D; 0;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    Thread one &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            a &#x3D; 1;</span><br><span class="line">            x &#x3D; b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread other &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            b &#x3D; 1;</span><br><span class="line">            y &#x3D; a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    one.start();other.start();</span><br><span class="line">    one.join();other.join();</span><br><span class="line">    System.out.println(“(” + x + “,” + y + “)”);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>运行结果可能为(1,0)、(0,1)或(1,1)，也可能是(0,0)。因为，在实际运行时，代码指令可能并不是严格按照代码语句顺序执行的。大多数现代微处理器都会采用将指令乱序执行（out-of-order execution，简称OoOE或OOE）的方法，在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待3。通过乱序执行的技术，处理器可以大大提高执行效率。而这就是<strong>指令重排</strong>。</p>
<h4 id="3）内存屏障"><a href="#3）内存屏障" class="headerlink" title="3）内存屏障"></a>3）内存屏障</h4><p><strong>内存屏障</strong>，也叫内存栅栏，是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。</p>
<ul>
<li><strong>LoadLoad屏障</strong>：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li>
<li><strong>StoreStore屏障</strong>：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li>
<li><strong>LoadStore屏障</strong>：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li>
<li><strong>StoreLoad屏障</strong>：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。        在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</li>
</ul>
<h4 id="4）happen-before原则"><a href="#4）happen-before原则" class="headerlink" title="4）happen-before原则"></a>4）happen-before原则</h4><ul>
<li><strong>单线程happen-before原则</strong>：在同一个线程中，书写在前面的操作happen-before后面的操作。 锁的happen-before原则：同一个锁的unlock操作happen-before此锁的lock操作。</li>
<li><strong>volatile的happen-before原则</strong>：对一个volatile变量的写操作happen-before对此变量的任意操作(当然也包括写操作了)。</li>
<li><strong>happen-before的传递性原则</strong>：如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作。</li>
<li><strong>线程启动的happen-before原则</strong>：同一个线程的start方法happen-before此线程的其它方法。</li>
<li><strong>线程中断的happen-before原则</strong> ：对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。</li>
<li><strong>线程终结的happen-before原则：</strong> 线程中的所有操作都happen-before线程的终止检测。</li>
<li><strong>对象创建的happen-before原则：</strong> 一个对象的初始化完成先于他的finalize方法调用。</li>
</ul>
<h3 id="7-简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。"><a href="#7-简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。" class="headerlink" title="7.简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。"></a>7.简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。</h3><p><strong>思路：</strong> 先说明一下什么是类加载器，可以给面试官画个图，再说一下类加载器存在的意义，说一下双亲委派模型，最后阐述怎么打破双亲委派模型。</p>
<p><strong>我的答案：</strong></p>
<h4 id="1-什么是类加载器？"><a href="#1-什么是类加载器？" class="headerlink" title="1) 什么是类加载器？"></a>1) 什么是类加载器？</h4><p><strong>类加载器</strong> 就是根据指定全限定名称将class文件加载到JVM内存，转为Class对象。</p>
<blockquote>
<ul>
<li>启动类加载器（Bootstrap  ClassLoader）：由C++语言实现（针对HotSpot）,负责将存放在<JAVA_HOME>\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中。</li>
<li>其他类加载器：由Java语言实现，继承自抽象类ClassLoader。如：</li>
</ul>
<blockquote>
<ul>
<li>扩展类加载器（Extension ClassLoader）：负责加载<JAVA_HOME>\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库。</li>
<li>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</li>
</ul>
</blockquote>
</blockquote>
<h4 id="2）双亲委派模型"><a href="#2）双亲委派模型" class="headerlink" title="2）双亲委派模型"></a>2）双亲委派模型</h4><p><strong>双亲委派模型工作过程是：</strong></p>
<blockquote>
<p>如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。</p>
</blockquote>
<p>双亲委派模型图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1c54cf4ad886b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h4 id="3）为什么需要双亲委派模型？"><a href="#3）为什么需要双亲委派模型？" class="headerlink" title="3）为什么需要双亲委派模型？"></a>3）为什么需要双亲委派模型？</h4><p>在这里，先想一下，如果没有双亲委派，那么用户是不是可以<strong>自己定义一个java.lang.Object的同名类</strong>，<strong>java.lang.String的同名类</strong>，并把它放到ClassPath中,那么<strong>类之间的比较结果及类的唯一性将无法保证</strong>，因此，为什么需要双亲委派模型？<strong>防止内存中出现多份同样的字节码</strong></p>
<h4 id="4）怎么打破双亲委派模型？"><a href="#4）怎么打破双亲委派模型？" class="headerlink" title="4）怎么打破双亲委派模型？"></a>4）怎么打破双亲委派模型？</h4><p>打破双亲委派机制则不仅<strong>要继承ClassLoader</strong>类，还要<strong>重写loadClass和findClass</strong>方法。</p>
<h3 id="8-说说你知道的几种主要的JVM参数"><a href="#8-说说你知道的几种主要的JVM参数" class="headerlink" title="8.说说你知道的几种主要的JVM参数"></a>8.说说你知道的几种主要的JVM参数</h3><p><strong>思路：</strong> 可以说一下堆栈配置相关的，垃圾收集器相关的，还有一下辅助信息相关的。</p>
<p><strong>我的答案：</strong></p>
<h4 id="1）堆栈配置相关"><a href="#1）堆栈配置相关" class="headerlink" title="1）堆栈配置相关"></a>1）堆栈配置相关</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k </span><br><span class="line">-XX:MaxPermSize&#x3D;16m -XX:NewRatio&#x3D;4 -XX:SurvivorRatio&#x3D;4 -XX:MaxTenuringThreshold&#x3D;0</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>-Xmx3550m：</strong> 最大堆大小为3550m。</p>
<p><strong>-Xms3550m：</strong> 设置初始堆大小为3550m。</p>
<p><strong>-Xmn2g：</strong> 设置年轻代大小为2g。</p>
<p><strong>-Xss128k：</strong> 每个线程的堆栈大小为128k。</p>
<p><strong>-XX:MaxPermSize：</strong>  设置持久代大小为16m</p>
<p><strong>-XX:NewRatio=4:</strong> 设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。</p>
<p><strong>-XX:SurvivorRatio=4：</strong> 设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6</p>
<p><strong>-XX:MaxTenuringThreshold=0：</strong> 设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。</p>
<h4 id="2）垃圾收集器相关"><a href="#2）垃圾收集器相关" class="headerlink" title="2）垃圾收集器相关"></a>2）垃圾收集器相关</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC</span><br><span class="line">-XX:ParallelGCThreads&#x3D;20</span><br><span class="line">-XX:+UseConcMarkSweepGC </span><br><span class="line">-XX:CMSFullGCsBeforeCompaction&#x3D;5</span><br><span class="line">-XX:+UseCMSCompactAtFullCollection：</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>-XX:+UseParallelGC：</strong> 选择垃圾收集器为并行收集器。</p>
<p><strong>-XX:ParallelGCThreads=20：</strong> 配置并行收集器的线程数</p>
<p><strong>-XX:+UseConcMarkSweepGC：</strong> 设置年老代为并发收集。</p>
<p><strong>-XX:CMSFullGCsBeforeCompaction</strong>：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。</p>
<p><strong>-XX:+UseCMSCompactAtFullCollection：</strong> 打开对年老代的压缩。可能会影响性能，但是可以消除碎片</p>
<h4 id="3）辅助信息相关"><a href="#3）辅助信息相关" class="headerlink" title="3）辅助信息相关"></a>3）辅助信息相关</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGC</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>-XX:+PrintGC 输出形式:</strong></p>
<p>[GC 118250K-&gt;113543K(130112K), 0.0094143 secs] [Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs]</p>
<p><strong>-XX:+PrintGCDetails 输出形式:</strong></p>
<p>[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs] [GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs</p>
<h3 id="9-怎么打出线程栈信息。"><a href="#9-怎么打出线程栈信息。" class="headerlink" title="9.怎么打出线程栈信息。"></a>9.怎么打出线程栈信息。</h3><p><strong>思路：</strong> 可以说一下jps，top ，jstack这几个命令，再配合一次排查线上问题进行解答。</p>
<p><strong>我的答案：</strong></p>
<ul>
<li>输入jps，获得进程号。</li>
<li>top -Hp pid 获取本进程中所有线程的CPU耗时性能</li>
<li>jstack pid命令查看当前java进程的堆栈状态</li>
<li>或者 jstack -l  &gt; /tmp/output.txt 把堆栈信息打到一个txt文件。</li>
<li>可以使用fastthread 堆栈定位，<a href="http://fastthread.io/" target="_blank" rel="noopener">fastthread.io/</a></li>
</ul>
<h3 id="10-强引用、软引用、弱引用、虚引用的区别？"><a href="#10-强引用、软引用、弱引用、虚引用的区别？" class="headerlink" title="10.强引用、软引用、弱引用、虚引用的区别？"></a>10.强引用、软引用、弱引用、虚引用的区别？</h3><p><strong>思路：</strong> 先说一下四种引用的定义，可以结合代码讲一下，也可以扩展谈到ThreadLocalMap里弱引用用处。</p>
<p><strong>我的答案：</strong></p>
<h4 id="1）强引用"><a href="#1）强引用" class="headerlink" title="1）强引用"></a>1）强引用</h4><p>我们平时new了一个对象就是强引用，例如 Object obj = new Object();即使在内存不足的情况下，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。</p>
<h4 id="2）软引用"><a href="#2）软引用" class="headerlink" title="2）软引用"></a>2）软引用</h4><p>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;String&gt; softRef&#x3D;new SoftReference&lt;String&gt;(str);     &#x2F;&#x2F; 软引用</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>用处：</strong> 软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。</p>
<p>（1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建</p>
<p>（2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出</p>
<p>如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Browser prev &#x3D; new Browser();               &#x2F;&#x2F; 获取页面进行浏览</span><br><span class="line">SoftReference sr &#x3D; new SoftReference(prev); &#x2F;&#x2F; 浏览完毕后置为软引用        </span><br><span class="line">if(sr.get()!&#x3D;null)&#123; </span><br><span class="line">    rev &#x3D; (Browser) sr.get();           &#x2F;&#x2F; 还没有被回收器回收，直接获取</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    prev &#x3D; new Browser();               &#x2F;&#x2F; 由于内存吃紧，所以对软引用的对象回收了</span><br><span class="line">    sr &#x3D; new SoftReference(prev);       &#x2F;&#x2F; 重新构建</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="3）弱引用"><a href="#3）弱引用" class="headerlink" title="3）弱引用"></a>3）弱引用</h4><p>具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str&#x3D;new String(&quot;abc&quot;);    </span><br><span class="line">WeakReference&lt;String&gt; abcWeakRef &#x3D; new WeakReference&lt;String&gt;(str);</span><br><span class="line">str&#x3D;null;</span><br><span class="line">等价于</span><br><span class="line">str &#x3D; null;</span><br><span class="line">System.gc();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="4）虚引用"><a href="#4）虚引用" class="headerlink" title="4）虚引用"></a>4）虚引用</h4><p>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。</p>
<h3 id="11-待更新"><a href="#11-待更新" class="headerlink" title="11.待更新"></a>11.待更新</h3><h3 id="參考与感谢"><a href="#參考与感谢" class="headerlink" title="參考与感谢"></a>參考与感谢</h3><ul>
<li>为什么新生代内存需要有两个Survivor区 <a href="https://blog.csdn.net/antony9118/article/details/51425581" target="_blank" rel="noopener">blog.csdn.net/antony9118/…</a></li>
<li>JVM内存模型、指令重排、内存屏障概念解析：<a href="https://www.cnblogs.com/chenyangyao/p/5269622.html" target="_blank" rel="noopener">www.cnblogs.com/chenyangyao…</a></li>
<li>java 8大happen-before原则超全面详解 <a href="https://www.jianshu.com/p/1508eedba54d" target="_blank" rel="noopener">www.jianshu.com/p/1508eedba…</a></li>
<li>JVM参数配置大全 <a href="https://www.cnblogs.com/edwardlauxh/archive/2010/04/25/1918603.html" target="_blank" rel="noopener">www.cnblogs.com/edwardlauxh…</a></li>
<li>Java 的强引用、弱引用、软引用、虚引用 <a href="https://www.cnblogs.com/gudi/p/6403953.html" target="_blank" rel="noopener">www.cnblogs.com/gudi/p/6403…</a></li>
<li>《深入理解Java虚拟机》</li>
</ul>
<p>作者：捡田螺的小男孩<br>链接：<a href="https://juejin.cn/post/6844903895123099662" target="_blank" rel="noopener">https://juejin.cn/post/6844903895123099662</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-02-06</span><i class="fa fa-tag"></i><span class="leancloud_visitors"></span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2021/02/06/问题记录/,Vector,问题记录,;" target="_blank" rel="noopener"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2021/02/06/%E7%BB%9F%E8%AE%A1%E4%BD%9C%E6%88%98%E5%8D%95%E4%BD%8D%E6%95%B0/" title="统计作战单位数">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2021/02/06/%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E7%82%B9%E6%95%B0/" title="可获得的最大点数">下一篇</a></li></ul></div><script src="/js/visitors.js"></script><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@latest/dist/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:false|| false, 
  app_id:'',
  app_key:'',
  placeholder:'念念不忘，必有回响...',
  path: window.location.pathname,
  serverURLs: '',
  visitor:true,
  recordIP:true,
  avatar:'mp'
})</script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/js/baidu-tongji.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":200,"height":350},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body></html>