<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Vector"><title>java知识点 · Vector</title><meta name="description" content="MathJax.Hub.Config({
tex2jax: {
  inlineMath: [['$','$'], ['\\(','\\)']],
  processEscapes: true
  }
});




问题记录：
详细描述ThreadPoolExecutor的各个参数的含义，介绍一个"><meta name="keywords" content="Vector的小窝"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Vector</a></h3><div class="description"><p>没人扶你的时候，自己要站直，路还长，背影要美！</p></div></div></div><ul class="social-links"><li><a href="https://github.com/IMVector" target="_blank" rel="noopener"><i class="fa fa-github"></i></a></li><li><a href="mailto:1769326712@qq.com"><i class="fa fa-envelope"></i></a></li><li><a href="http://sighttp.qq.com/authd?IDKEY=" target="_blank" rel="noopener"><i class="fa fa-qq"></i></a></li><li><a href="https://zhihu.com/people/" target="_blank" rel="noopener"><i class="fa fa-mortar-board"></i></a></li></ul><div class="footer"><div class="p"> <span>© 2017 - 2020 </span><i class="fa fa-star"></i><span> Vector</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><a href="https://github.com/mrcore/hexo-theme-Anatole-Core" target="_blank">Anatole-Core.  </a><span> &</span><a href="https://github.com/IMVector/blog_vector" target="_blank">Vector.  </a><a href="http://www.beian.miit.gov.cn/" target="_blank">&nbsp;粤ICP备15011643号</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">标签</a></li><li><a href="/about">关于</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>java知识点</a></h3></div><div class="post-content"><!--将该代码放入博客模板的head中即可-->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
  inlineMath: [['$','$'], ['\\(','\\)']],
  processEscapes: true
  }
});
</script>
<!--latex数学显示公式-->
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<h2 id="问题记录："><a href="#问题记录：" class="headerlink" title="问题记录："></a>问题记录：</h2><ol>
<li>详细描述ThreadPoolExecutor的各个参数的含义，介绍一个任务提交到线程池后的执行流程。</li>
<li>请简要说明Servlet中的生命周期</li>
<li>开启两个线程A、B，打印1到10，线程A打印奇数（1、3、5、7、9），线程B打印偶数（2、4、6、8、10）。</li>
<li>请编写代码实现单例模式 ，类名为Singleton</li>
<li>写一个Map转换成JavaBean的工具类方法，实现如下mapToObject方法（使用Java反射，不允许使用第三方类库）</li>
</ol>
<p>public static <T> T mapToObject(Map&lt;String, Object&gt; map, Class<T> beanClass){ </p>
<p>}</p>
<hr>
<p>数据库操作是我们经常使用的一个技能， 请你完成一个简单的用户密码验证过程 ，给定的条件如下：</p>
<p>数据库中存在个用户表:users ,表结构如下：</p>
<p>CREATE TABLE <code>users</code> (<br>  <code>uid</code> bigint(20) NOT NULL COMMENT ‘用户ID’,<br>  <code>user_name</code> varchar(32) NOT NULL  COMMENT ‘用户账号’,<br>  <code>password</code> varchar(64) NOT NULL  COMMENT ‘用户混淆密码’,<br>  PRIMARY KEY (<code>uid</code>),<br>  UNIQUE KEY <code>u_user_name</code> (<code>user_name</code>)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=’用户表’</p>
<p>完善以下方法<br>public boolean verifyPassword(String username,String password) {<br>      Connection con = getConnection () ;// getConnection（） 方法是个已有的方法可以获取到数据库连接 ，</p>
<pre><code>// here is your code</code></pre><p>}</p>
<blockquote>
<p>可以不用写Import 语句，只需要补充关键步骤即可</p>
</blockquote>
<hr>
<ol start="7">
<li>介绍HashMap的数据结构、扩容机制，HashMap与Hashtable的区别，是否是线程安全的，并介绍ConcurrentHashMap的实现机制。</li>
<li>介绍数据库连接池的实现方式。如何从连接池中获取连接、将连接放回连接池？使用连接池的优势是什么？列举一下自己用过的连接池。</li>
<li>什么是死锁？JAVA程序中什么情况下回出现死锁？如何避免出现死锁？</li>
<li>分布式锁有几种实现方式，并介绍每种方式的优缺点。</li>
<li>什么是TCP粘包拆包？为什么会出现粘包拆包？如何在应用层面解决此问题？</li>
<li>请大致描述一下BIO，AIO和NIO的区别？ </li>
<li>在JAVA语法中加载类的的方式有哪些？</li>
<li>建立三个线程A、B、C，A线程打印10次字母A，B线程打印10次字母B,C线程打印10次字母C，但是要求三个线程同时运行，并且实现交替打印，即按照ABCABCABC的顺序打印。</li>
<li>请列举5个spring框架中的注解，并说明注解的用法以及使用场景</li>
</ol>
<h2 id="反射的步骤如下"><a href="#反射的步骤如下" class="headerlink" title="反射的步骤如下"></a>反射的步骤如下</h2><ol>
<li>获取想要操作的类的Class对象，该Class对象是反射的核心，通过它可以调用类的任意方法。</li>
<li>调用Class对象所对应的类中定义的方法，这是反射的使用阶段。</li>
<li>使用反射API来获取并调用类的属性和方法等信息。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1: 获取Person类的Class对象</span></span><br><span class="line">Class clazz=Class.forName(<span class="string">"hello.java.reflect.Oersion"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2: 获取Person类的所有方法的信息</span></span><br><span class="line">Method[] method =clazz.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span>(Method m : method)&#123;</span><br><span class="line">  System.out.println(m.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3: 获取Person类的所有成员的属性信息</span></span><br><span class="line">Filed[] field = clazz.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span>(Field f : field)&#123;</span><br><span class="line">  System.out.println(f.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4： 获取Person类的所有构造方法的信息</span></span><br><span class="line">Constructor[] constructor = clazz.getDeclaredConstructors();</span><br><span class="line"><span class="keyword">for</span>(Constructor c:constructor)&#123;</span><br><span class="line">  System.out.println(c.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JVM的运行机制"><a href="#JVM的运行机制" class="headerlink" title="JVM的运行机制"></a>JVM的运行机制</h1><h2 id="JVM的内容"><a href="#JVM的内容" class="headerlink" title="JVM的内容"></a>JVM的内容</h2><p>包括一套字节码指令集、一组程序寄存器、一个虚拟机栈、一个虚拟机堆、一个方法区和一个垃圾回收器。</p>
<p><img src="img/JVM.png" alt=""></p>
<h2 id="程序的运行过程"><a href="#程序的运行过程" class="headerlink" title="程序的运行过程"></a>程序的运行过程</h2><p>（1）Java源文件被编译器编译成字节码文件。</p>
<p>（2）JVM将字节码文件编译成相应操作系统的机器码。</p>
<p>（3）机器码调用相应操作系统的本地方法库执行相应的方法。</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>JVM中的线程与操作系统中的线程是相互对应的，在JVM线程的本地存储、缓冲区分配、同步对象、栈、程序计数器等准备工作都完成时，JVM会调用操作系统的接口创建一个与之对应的原生线程</p>
<h2 id="JVM的后台线程"><a href="#JVM的后台线程" class="headerlink" title="JVM的后台线程"></a>JVM的后台线程</h2><ul>
<li>虚拟机线程</li>
<li>周期性任务线程</li>
<li>GC线程</li>
<li>编译器线程</li>
<li>信号分发线程</li>
</ul>
<h1 id="JVM的内存区域"><a href="#JVM的内存区域" class="headerlink" title="JVM的内存区域"></a>JVM的内存区域</h1><p>JVM的内存区域分为线程私有区域（程序计数器、虚拟机栈、本地方法区）、线程共享区域（堆、方法区）和直接内存</p>
<p><img src="img/JVM_Memery.png" alt=""></p>
<p>线程共享区域随虚拟机的启动而创建，随虚拟机的关闭而销毁。</p>
<p>Java进程可以通过堆外内存技术避免在Java堆和Native堆中来回复制数据带来的资源占用和性能消耗，因此堆外内存在高并发应用场景下被广泛使用（Netty、Flink、HBase、Hadoop都有用到堆外内存）。</p>
<p><strong>程序计数器</strong>（是线程私有的）是一块很小的内存空间，用于存储当前运行的线程所执行的字节码的行号指示器</p>
<p><strong>虚拟机栈</strong>(是线程私有的)是描述Java方法的执行过程的内存模型，它在当前栈帧（Stack Frame）中存储了局部变量表、操作数栈、动态链接、方法出口等信息。</p>
<p>栈帧用来记录方法的执行过程，在方法被执行时虚拟机会为其创建一个与之对应的栈帧，方法的执行和返回对应栈帧在虚拟机栈中的入栈和出栈。</p>
<p>在线程内部，每个方法的执行和返回都对应一个栈帧的入栈和出栈，每个运行中的线程当前只有一个栈帧处于活动状态。</p>
<p><strong>本地方法区</strong>（是线程私有的）本地方法栈为Native方法服务。</p>
<p><strong>堆</strong>：现代JVM采用分代收集算法，因此Java堆从GC（Garbage Collection，垃圾回收）的角度还可以细分为：新生代、老年代和永久代。</p>
<p><strong>方法区</strong>也被称为永久代，用于存储常量、静态变量、类信息、即时编译器编译后的机器码、运行时常量池等数据。</p>
<p><strong>永久代的内存回收主要针对常量池的回收和类的卸载</strong>，因此可回收的对象很少。</p>
<p>常量被存储在运行时常量池（Runtime ConstantPool）中，是方法区的一部分。静态变量也属于方法区的一部分。</p>
<h1 id="JVM的运行时内存"><a href="#JVM的运行时内存" class="headerlink" title="JVM的运行时内存"></a>JVM的运行时内存</h1><p>JVM的运行时内存也叫作JVM堆，从GC的角度可以将JVM堆分为新生代、老年代和永久代。</p>
<ul>
<li>其中新生代默认占1/3堆空间；</li>
<li>老年代默认占2/3堆空间；</li>
<li>永久代占非常少的堆空间。</li>
</ul>
<p>新生代又分为Eden区、ServivorFrom区和ServivorTo区，</p>
<ul>
<li>Eden区默认占8/10新生代空间，</li>
<li>ServivorFrom区默认占1/10新生代空间</li>
<li>ServivorTo区默认1/10新生代空间<br><img src="img/JVM_Mem_ratio.png" alt=""></li>
</ul>
<h2 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h2><p>（1）Eden区：Java新创建的对象首先会被存放在Eden区，如果新创建的对象属于大对象，则直接将其分配到老年代。大对象的定义和具体的JVM版本、堆大小和垃圾回收策略有关，一般为2KB～128KB，可通过XX:PretenureSizeThreshold设置其大小。在Eden区的内存空间不足时会触发MinorGC，对新生代进行一次垃圾回收。</p>
<p>（2）ServivorTo区：保留上一次MinorGC时的幸存者。</p>
<p>（3）ServivorFrom区：将上一次MinorGC时的幸存者作为这一次MinorGC的被扫描者。</p>
<h3 id="新生代GC算法MinorGC"><a href="#新生代GC算法MinorGC" class="headerlink" title="新生代GC算法MinorGC"></a>新生代GC算法MinorGC</h3><p><strong>新生代的GC过程叫作MinorGC，采用复制算法实现：</strong></p>
<p>（1）把在Eden区和ServivorFrom区中存活的对象复制到ServivorTo区。</p>
<p>如果某对象的年龄达到老年代的标准（对象晋升老年代的标准由XX:MaxTenuringThreshold设置，默认为15），则将其复制到老年代，同时把这些对象的年龄加1；如果ServivorTo区的内存空间不够，则也直接将其复制到老年代；如果对象属于大对象（大小为2KB～128KB的对象属于大对象，例如通过XX:PretenureSizeThreshold=2097152设置大对象为2MB,1024×1024×2Byte=2097152Byte=2MB），则也直接将其复制到老年代。</p>
<p>（2）清空Eden区和ServivorFrom区中的对象。</p>
<p>（3）将ServivorTo区和ServivorFrom区互换，原来的ServivorTo区成为下一次GC时的ServivorFrom区。</p>
<h2 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h2><p>老年代主要存放有长生命周期的对象和大对象。老年代的GC过程叫作MajorGC</p>
<p>在老年代，对象比较稳定，MajorGC不会被频繁触发。在进行MajorGC前，JVM会进行一次MinorGC，在MinorGC过后仍然出现老年代空间不足或无法找到足够大的连续空间分配给新创建的大对象时，会触发MajorGC进行垃圾回收，释放JVM的内存空间。</p>
<h3 id="老年代GC算法MajorGC"><a href="#老年代GC算法MajorGC" class="headerlink" title="老年代GC算法MajorGC"></a>老年代GC算法MajorGC</h3><p><strong>MajorGC采用标记清除算法</strong>，该算法首先会扫描所有对象并标记存活的对象，然后回收未被标记的对象，并释放内存空间。</p>
<p>老年代主要存放有长生命周期的对象和大对象。老年代的GC过程叫作MajorGC。在老年代，对象比较稳定，MajorGC不会被频繁触发。在进行MajorGC前，JVM会进行一次MinorGC，在MinorGC过后仍然出现老年代空间不足或无法找到足够大的连续空间分配给新创建的大对象时，会触发MajorGC进行垃圾回收，释放JVM的内存空间。</p>
<p><strong>MajorGC采用标记清除算法</strong>，该算法首先会扫描所有对象并标记存活的对象，然后回收未被标记的对象，并释放内存空间。</p>
<p>因为要先扫描老年代的所有对象再回收，所以MajorGC的耗时较长。MajorGC的标记清除算法容易产生内存碎片。在老年代没有内存空间可分配时，会抛出Out Of Memory异常。</p>
<h2 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h2><p>永久代指内存的永久保存区域，主要存放Class和Meta（元数据）的信息。Class在类加载时被放入永久代。GC不会在程序运行期间对永久代的内存进行清理</p>
<p>在Java 8中永久代已经被元数据区（也叫作元空间）取代。元数据区的作用和永久代类似，二者最大的区别在于：元数据区并没有使用虚拟机的内存，而是直接使用操作系统的本地内存。因此，元空间的大小不受JVM内存的限制，只和操作系统的内存有关。</p>
<h1 id="垃圾回收与算法"><a href="#垃圾回收与算法" class="headerlink" title="垃圾回收与算法"></a>垃圾回收与算法</h1><p>Java采用引用计数法和可达性分析来确定对象是否应该被回收</p>
<p><img src="img/gb_det.png" alt=""></p>
<h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>引用计数法容易产生循环引用问题。循环引用指两个对象相互引用，导致它们的引用一直存在，而不能被回收</p>
<h2 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h2><p>为了解决引用计数法的循环引用问题，Java还采用了可达性分析来判断对象是否可以被回收。</p>
<p>不可达对象要经过至少两次标记才能判定其是否可以被回收，如果在两次标记后该对象仍然是不可达的，则将被垃圾收集器回收。</p>
<h2 id="Java中常用的垃圾回收算法"><a href="#Java中常用的垃圾回收算法" class="headerlink" title="Java中常用的垃圾回收算法"></a>Java中常用的垃圾回收算法</h2><p>Java中常用的垃圾回收算法有标记清除（Mark-Sweep）、复制（Copying）、标记整理（Mark-Compact）和分代收集（Generational Collecting）这4种垃圾回收算法</p>
<p><img src="img/gc_ali.png" alt=""></p>
<h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p>在标记阶段标记所有需要回收的对象，在清除阶段清除可回收的对象并释放其所占用的内存空间<br><img src="img/mark_delete.png" alt=""></p>
<p>由于标记清除算法在清理对象所占用的内存空间后并没有重新整理可用的内存空间，因此如果内存中可被回收的小对象居多，则会引起内存碎片化的问题，继而引起大对象无法获得连续可用空间的问题。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>复制算法是为了解决标记清除算法内存碎片化的问题而设计的。复制算法首先将内存划分为两块大小相等的内存区域，即区域1和区域2，新生成的对象都被存放在区域1中，在区域1内的对象存储满后会对区域1进行一次标记，并将标记后仍然存活的对象全部复制到区域2中，这时区域1将不存在任何存活的对象，直接清理整个区域1的内存即可</p>
<p><img src="img/copy_ali.png" alt=""></p>
<p>复制算法的内存清理效率高且易于实现，但由于同一时刻只有一个内存区域可用，即可用的内存空间被压缩到原来的一半，因此存在大量的内存浪费。同时，在系统中有大量长时间存活的对象时，这些对象将在内存区域1和内存区域2之间来回复制而影响系统的运行效率。因此，该算法只在对象为“朝生夕死”状态时运行效率较高。</p>
<h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><p>标记整理算法结合了标记清除算法和复制算法的优点，其标记阶段和标记清除算法的标记阶段相同，在标记完成后将存活的对象移到内存的另一端，然后清除该端的对象并释放内存</p>
<p><img src="img/mark_swap.png" alt=""></p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>针对不同的对象类型，JVM采用了不同的垃圾回收算法，该算法被称为分代收集算法。</p>
<p>新生代主要存放新生成的对象，其特点是对象数量多但是生命周期短，在每次进行垃圾回收时都有大量的对象被回收；老年代主要存放大对象和生命周期长的对象，因此可回收的对象相对较少。</p>
<p>大部分JVM在新生代都采用了复制算法</p>
<p>JVM将新生代进一步划分为一块较大的Eden区和两块较小的Servivor区，Servivor区又分为ServivorFrom区和ServivorTo区。JVM在运行过程中主要使用Eden区和ServivorFrom区，进行垃圾回收时会将在Eden区和ServivorFrom区中存活的对象复制到ServivorTo区，然后清理Eden区和ServivorFrom区的内存空间</p>
<p>老年代主要存放生命周期较长的对象和大对象，因而每次只有少量非存活的对象被回收，因而在老年代采用标记清除算法。</p>
<p>若Servivor区的对象经过一次GC后仍然存活，则其年龄加1。在默认情况下，对象在年龄达到15时，将被移到老年代。</p>
<h1 id="Java中的四种引用类型"><a href="#Java中的四种引用类型" class="headerlink" title="Java中的四种引用类型"></a>Java中的四种引用类型</h1><p>Java中的引用类型有4种，分别为强引用、软引用、弱引用和虚引用</p>
<h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>在把一个对象赋给一个引用变量时，这个引用变量就是一个强引用。有强引用的对象一定为可达性状态，所以不会被垃圾回收机制回收。因此，强引用是造成Java内存泄漏（Memory Link）的主要原因。</p>
<h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>软引用通过SoftReference类实现。如果一个对象只有软引用，则在系统内存空间不足时该对象将被回收。</p>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>弱引用通过WeakReference类实现，如果一个对象只有弱引用，则在垃圾回收过程中一定会被回收。</p>
<h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>虚引用通过PhantomReference类实现，虚引用和引用队列联合使用，主要用于跟踪对象的垃圾回收状态。</p>
<h1 id="分代收集算法与分区收集算法"><a href="#分代收集算法与分区收集算法" class="headerlink" title="分代收集算法与分区收集算法"></a>分代收集算法与分区收集算法</h1><h2 id="分代收集算法-1"><a href="#分代收集算法-1" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><h3 id="新生代-复制算法"><a href="#新生代-复制算法" class="headerlink" title="新生代 复制算法"></a>新生代 复制算法</h3><p>新生代主要存储短生命周期的对象，因此在垃圾回收的标记阶段会标记大量已死亡的对象及少量存活的对象，因此只需选用复制算法将少量存活的对象复制到内存的另一端并清理原区域的内存即可。</p>
<h3 id="老年代-标记清除算法"><a href="#老年代-标记清除算法" class="headerlink" title="老年代 标记清除算法"></a>老年代 标记清除算法</h3><p>老年代主要存放长生命周期的对象和大对象，可回收的对象一般较少，因此JVM采用标记清除算法进行垃圾回收，直接释放死亡状态的对象所占用的内存空间即可。</p>
<h2 id="分区收集算法"><a href="#分区收集算法" class="headerlink" title="分区收集算法"></a>分区收集算法</h2><p>分区收集算法可以根据系统可接受的停顿时间，每次都快速回收若干个小区域的内存，以缩短垃圾回收时系统停顿的时间，最后以多次并行累加的方式逐步完成整个内存区域的垃圾回收。</p>
<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>针对新生代提供的垃圾收集器有Serial、ParNew、Parallel Scavenge，针对老年代提供的垃圾收集器有Serial Old、Parallel Old、CMS，还有针对不同区域的G1分区收集算法<br><img src="img/ali_for_gen.png" alt=""></p>
<h1 id="垃圾收集器-1"><a href="#垃圾收集器-1" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><h2 id="Serial垃圾收集器：单线程，复制算法（新生代）"><a href="#Serial垃圾收集器：单线程，复制算法（新生代）" class="headerlink" title="Serial垃圾收集器：单线程，复制算法（新生代）"></a>Serial垃圾收集器：单线程，复制算法（新生代）</h2><p>Serial 垃圾收集器计数复制算法实现，他是一个单线程收集器，在它正在进行垃圾收集时，必须暂停其他所有工作线程，直到垃圾收集结束。</p>
<p>Serial垃圾收集器是Java虚拟机运行在Client模式下的新生代的默认垃圾收集器。</p>
<h2 id="ParNew垃圾收集器：多线程，复制算法（新生代）"><a href="#ParNew垃圾收集器：多线程，复制算法（新生代）" class="headerlink" title="ParNew垃圾收集器：多线程，复制算法（新生代）"></a>ParNew垃圾收集器：多线程，复制算法（新生代）</h2><p>ParNew垃圾收集器在垃圾收集过程中会暂停所有其他工作线程，是Java虚拟机运行在Server模式下的新生代的默认垃圾收集器。</p>
<p>ParNew垃圾收集器默认开启与CPU同等数量的线程进行垃圾回收，在Java应用启动时可通过-XX:ParallelGCThreads参数调节ParNew垃圾收集器的工作线程数。</p>
<h2 id="Parallel-Scavenge垃圾收集器：多线程，复制算法（新生代）"><a href="#Parallel-Scavenge垃圾收集器：多线程，复制算法（新生代）" class="headerlink" title="Parallel Scavenge垃圾收集器：多线程，复制算法（新生代）"></a>Parallel Scavenge垃圾收集器：多线程，复制算法（新生代）</h2><p>Parallel Scavenge收集器是为提高新生代垃圾收集效率而设计的垃圾收集器，基于多线程复制算法实现，<strong>在系统吞吐量上有很大的优化</strong>，可以更高效地利用CPU尽快完成垃圾回收任务</p>
<p>提供了三个参数用于调节、控制垃圾回收的停顿时间及吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数，控制吞吐量大小的-XX:GCTimeRatio参数和控制自适应调节策略开启与否的UseAdaptiveSizePolicy参数。</p>
<h2 id="Serial-Old-垃圾收集器：单线程，标记整理算法"><a href="#Serial-Old-垃圾收集器：单线程，标记整理算法" class="headerlink" title="Serial Old 垃圾收集器：单线程，标记整理算法"></a>Serial Old 垃圾收集器：单线程，标记整理算法</h2><p>Serial Old垃圾收集器是JVM运行在Client模式下的老年代的默认垃圾收集器。</p>
<p>新生代的Serial垃圾收集器和老年代的Serial Old垃圾收集器可搭配使用</p>
<h2 id="Parallel-Old垃圾收集器：多线程，标记整理算法"><a href="#Parallel-Old垃圾收集器：多线程，标记整理算法" class="headerlink" title="Parallel Old垃圾收集器：多线程，标记整理算法"></a>Parallel Old垃圾收集器：多线程，标记整理算法</h2><p>Parallel Old 垃圾收集器在设计张优先考虑系统吞吐量，其次考虑停顿时间等因素，如果系统对吞吐量的要求较高，则可以优先考虑新生代的Parallel Scavenge垃圾收集器和老年代的Parallel Old垃圾收集器的配合使用。</p>
<h2 id="CMS垃圾收集器"><a href="#CMS垃圾收集器" class="headerlink" title="CMS垃圾收集器"></a>CMS垃圾收集器</h2><p>CMS的主要目标是达到最短的垃圾回收停顿时间，基于线程的标记清除算法实现，以便在多线程并发环境下以最短的垃圾收集停顿时间提高系统的稳定性。</p>
<p>CMS工作步骤：</p>
<ol>
<li>初始标记：只标记和GC Roots直接关联的对象，速度很快，需要暂停所有工作线程。</li>
<li>并发标记:和用户线程一起工作，执行GC Roots跟踪标记过程，不需要暂停工作线程</li>
<li>重新标记：在并发标记过程中用户线程继续运行，导致在垃圾回收过程中部分对象的状态发生变化，为了确保这部分对象的状态正确性，需要对其重新标记并暂停工作线程。</li>
<li>并发清除：和用户线程一起工作，执行清除GC Roots不可达对象的任务不需要暂停工作线程。</li>
</ol>
<p>CMS垃圾收集器在和其他用户线程一起工作时（并发标记和并发清除）不需要暂停用户线程，有效缩短了垃圾回收时系统的停顿时间，同时由于CMS垃圾收集器和用户线程一起工作，因此其并行度和效率也有很大提升</p>
<h2 id="G1垃圾收集器"><a href="#G1垃圾收集器" class="headerlink" title="G1垃圾收集器"></a>G1垃圾收集器</h2><p>G1(Gabage First)垃圾收集器为了避免全区域垃圾收集引起的系统停顿，将堆内存划分为大小固定的几个独立区域，独立使用这些区域的内存资源并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，在垃圾回收过程中根据系统允许的最长垃圾收集时间，优先回收垃圾最多的区域。</p>
<p>相对于CMS收集器，G1垃圾收集器两个突出的改进：</p>
<ul>
<li>基于标记整理算法，不产生内存碎片。</li>
<li>可以精确的控制停顿时间，在不牺牲吞吐量的前提下实现短停顿垃圾回收。</li>
</ul>
<h1 id="网络编程模型"><a href="#网络编程模型" class="headerlink" title="网络编程模型"></a>网络编程模型</h1><h2 id="阻塞I-O模型"><a href="#阻塞I-O模型" class="headerlink" title="阻塞I/O模型"></a>阻塞I/O模型</h2><p>阻塞I/O的工作流程为：在用户线程发出I/O请求之后，内核会检查数据是否就绪，此时用户线程一直组设等待内存数据 就绪；在内存数据就绪后，内核将数组复制到用夯实线程中，并返回I/O执行结果到用户线程，此时用户线程将解除阻塞状态并开始处理数据。</p>
<h2 id="非阻塞I-O模型"><a href="#非阻塞I-O模型" class="headerlink" title="非阻塞I/O模型"></a>非阻塞I/O模型</h2><p>非阻塞I/O模型指用户线程在发器一个I/O操作后，无需阻塞便可以马上得到内核返回的一个结果。</p>
<p>在非阻塞I/O模型中，用户线程需要不断询问内核数据是否就绪，在内存数据还未就绪时，用户线程可以处理其他任务，在内核数据就绪后可立即获取数据并进行相应的操作。</p>
<h2 id="多路复用I-O模型"><a href="#多路复用I-O模型" class="headerlink" title="多路复用I/O模型"></a>多路复用I/O模型</h2><p>时多线程并发编程用的比较多的模型，Java NIO就是基于多路复用I/O模型实现的。</p>
<p>在多路复用I/O模型中回右一个被称为Selector的线程不断轮询多个Socket的状态，只有在Socket的有读写事件时，才会通知用户线程进行I/O读写操作。</p>
<p>多路复用I/O模型在连接数众多且消息体不大的情况下有很大的优势。</p>
<p>非阻塞I/O模型在每个用户线程中都进行Socket状态检查，而在多路复用I/O模型中是在系统内核中进行Socket状态检查的，这也是多路复用I/O模型比非阻塞I/O模型效率高的原因。</p>
<p>对于多路复用I/O模型来说，在事件响应体（消息体）很大时，Selector线程就会成为性能瓶颈，导致后续的事件迟迟得不到处理，影响下一轮的事件轮询。</p>
<h2 id="信号驱动I-O模型"><a href="#信号驱动I-O模型" class="headerlink" title="信号驱动I/O模型"></a>信号驱动I/O模型</h2><p>在信号驱动I/O模型中，在用户线程发起一个I/O请求操作时，系统会为该请求对应的Socket注册一个信号函数，然后用户线程可以继续执行其他业务逻辑；在内核数据就绪时，系统会发送一个信号到用户线程，用户线程在接受到该信号后，会在信号函数中调用对应的I/O读写操作完成时机的I/O请求操作。</p>
<h2 id="异步I-O模型"><a href="#异步I-O模型" class="headerlink" title="异步I/O模型"></a>异步I/O模型</h2><p>在异步I/O模型中，用户线程会发起一个asynchronous read 操作到内核，内核在接收到Synchronous read请求后会立即返回一个状态，来说明请求是否成功发起，在此过程中用户线程不会发生任何阻塞。接着，内核会等待数据准备完成并将数据复制到用户线程，通知用户线程Asynchronous读操作已完成。在异步I/O模型中，用户线程不需要关心整个I/O操作时如何进行的，只需发起一个请求，在接收到内核返回的成功或失败信号时说明I/O操作已经完成，直接使用数据即可。</p>
<p>一步I/Oc操作需要操作系统的底层支持，在Java 7 中提供了Asynchronous I/O操作。</p>
<h2 id="Java-I-O"><a href="#Java-I-O" class="headerlink" title="Java I/O"></a>Java I/O</h2><p>在整个Java.io包中最重要的5个类和一个接口。5个类指的是File、OutPutStream、InputStream、Writer、Reader,一个接口指的是Serializable。</p>
<h2 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h2><p>Java NIO的实现主要涉及三大核心内容：Selector（选择器）、Channel（通道）和Buffer(缓冲区)。</p>
<p>传统I/O基于数据流进行I/O读写操作；而Java NIO基于channel 和BUffer 进行I/O读写操作，并且数据总是被从Channel读取到Buffer中，或者从Buffer写入Channel中</p>
<p>Java NIO和传统I/O的最大区别如下:</p>
<ul>
<li>I/O是面向流的，NIO是面向缓冲区的。</li>
<li>传统I/O的流操作时阻塞模式的，NIO的流操作是非阻塞模式的。</li>
</ul>
<h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>Channel和I/O中的Stream（流）类似，只不过Stream是单向的（例如InputStream、OutputStream），而Channel是双向的，既可以用来进行读操作，也可以用来进行写操作。</p>
<p>NIO中Channel的主要实现有：FileChannel、DatagramChannel、SocketChannel、ServerSocketChannel，分别对应文件的I/O、UDP、TCP I/O、Socket Client和Socker Server操作。</p>
<h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>Buffer实际上是一个容器，其内部通过一个连续的字节数组存储I/O上的数据。</p>
<p>常用的Buffer实现类有：ByteBuffer、IntBuffer、CharBuffer、LongBuffer、DoubleBuffer、FloatBuffer、ShortBuffer</p>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>Selector用于检测多个注册的Channel上是否有I/O事件发生，并对检测到的I/O事件进行相应的相应和处理。</p>
<h1 id="JVM的类加载机制"><a href="#JVM的类加载机制" class="headerlink" title="JVM的类加载机制"></a>JVM的类加载机制</h1><h2 id="JVM的类加载阶段"><a href="#JVM的类加载阶段" class="headerlink" title="JVM的类加载阶段"></a>JVM的类加载阶段</h2><p>加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化<br><img src="img/class_loader_proc.png" alt=""></p>
<h2 id="1、加载"><a href="#1、加载" class="headerlink" title="1、加载"></a>1、加载</h2><p>指JVM读取Class文件，并且根据Class文件描述创建java.lang.Class对象的过程。</p>
<p>类加载过程主要包含将Class文件读取到运行时区域的方法区内，在堆中创建java.lang.Class对象，并封装类在方法区的数据结构的过程。</p>
<h2 id="2、验证"><a href="#2、验证" class="headerlink" title="2、验证"></a>2、验证</h2><p>主要用于确保Class文件符合当前虚拟机的要求，保障虚拟机自身的安全，只有通过验证的Class文件才能被JVM加载。</p>
<h2 id="3、准备"><a href="#3、准备" class="headerlink" title="3、准备"></a>3、准备</h2><p>主要工作是在方法区中为类变量分配内存空间并设置类中变量的初始值。</p>
<p>静态变量在准备阶段的初始值是0，赋值的动作是在对象初始化时完成的。</p>
<p>JVM在编译阶段后会为final类型的变量生成其对应的ConstantValue属性，虚拟机在准备阶段会根据ConstanValue属性给变量赋值。</p>
<h2 id="4、解析"><a href="#4、解析" class="headerlink" title="4、解析"></a>4、解析</h2><p>JVM会将常量池中的符号引用替换为直接引用</p>
<h2 id="5、初始化"><a href="#5、初始化" class="headerlink" title="5、初始化"></a>5、初始化</h2><p>主要通过执行类构造器的<client>方法为类进行初始化</p>
<p><client>方法是在编译阶段由编译器自动收集类中静态语句块和变量的赋值操作组成的。JVM规定，只有在父类的<client>方法都执行成功后，子类中的<client>方法才可以被执行。在一个类中既没有静态变量赋值操作也没有静态语句块时，编译器不会为该类生成<client>方法。</p>
<p>发生以下几种情况时，JVM不会执行类的初始化流程：</p>
<ul>
<li>常量在编译时会将其常量值存入使用该常量的类的常量池中，该过程不需要调用常量所在的类，因此不会出发该常量类的初始化。</li>
<li>在子类引用父类的静态字段时，不会触发子类的初始化，只会触发父类的初始化。</li>
<li>定义对象数组，不会触发该类的初始化。</li>
<li>在使用类名获取Class对象时不会触发类的初始化。</li>
<li>在使用Ckass.ForName加载指定的类时，可以通过initialize参数设置是否需要对类进行初始化。</li>
<li>在使用ClassLoader默认的loadClass方法加载类时不会触发该类的初始化</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>JVM提供了3种类加载器，分别是启动类加载器、扩展类加载器和应用程序类加载器</p>
<p><img src="img/class_loader_type.png" alt=""></p>
<p>1、启动类加载器：负责加载Java_HOME/lib目录中的类库，或通过-Xbootclasspath参数指定路径中被虚拟机认可的类库。</p>
<p>2、扩展类加载器：负责加载Java_HOME/lib/ext目录中的类库，或通过java.ext.dirs系统变量加载指定路径中的类库。</p>
<p>3、应用程序类加载器：负责加载用户路径（classpath）上的类库、</p>
<h2 id="双亲委派机制（重要）"><a href="#双亲委派机制（重要）" class="headerlink" title="双亲委派机制（重要）"></a>双亲委派机制（重要）</h2><p>JVM通过双亲委派机制对类进行加载。双亲委派机制指一个类在收到类加载请求后不会尝试自己加载这个类，而是把该类加载请求向上委派给其父类去完成，其父类在接收到该类加载请求后又会将其委派给自己的父类，以此类推，这样所有的类加载请求都被向上委派到启动类加载器中。</p>
<p>若父类加载器在接收到类加载请求后发现自己也无法加载该类（通常原因时该类的Class文件在父类的类加载路径中不存在），则父类会将该信息反馈给子类并向下委派子类加载器加载该类，直到该类被成功加载，若找不到该类，则JVM会抛出ClassNotFound异常。<br><img src="img/parent_class_loader.png" alt=""></p>
<ol>
<li>将自定义加载器挂载到应用程序类加载器。</li>
<li>应用程序类加载器将类加载请求委托给扩展类加载器。</li>
<li>扩展类加载器将类加载请求委托给七大类加载器。</li>
<li>启动类加载器在加载路径下查找并加载Class文件，如果未找到目标Class文件，则交由扩展类加载器加-载。</li>
<li>扩展类加载器在加载路径下查找并加载Class文件，如果未找到目标Class文件，则交由自定义加载器加载。</li>
<li>应用程序类加载器在加载路径下查找并加载Class文件，如果未找到目标Class文件，则交由自定义加载器加载。</li>
<li>在自定义加载器下查找并加载用户指定目录下的Class文件，如果在自定义加载路径下未找到目标Class文件，则抛出ClassNotFound异常。</li>
</ol>
<p><strong>双亲委派机制的核心时保障类的唯一性和安全性。</strong></p>
<p>OSGI(Open Service Gateway Initiative)是 Java动态化模块系统的一系列规范，旨在为实现Java程序员的模块化编程提供基础条件。</p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h3 id="ArrayList：不适合随机插入和删除的操作，更适合随机查找和遍历的操作。"><a href="#ArrayList：不适合随机插入和删除的操作，更适合随机查找和遍历的操作。" class="headerlink" title="ArrayList：不适合随机插入和删除的操作，更适合随机查找和遍历的操作。"></a>ArrayList：不适合随机插入和删除的操作，更适合随机查找和遍历的操作。</h3><h3 id="Vector：基于数组实现，增删慢，查询快，线程安全"><a href="#Vector：基于数组实现，增删慢，查询快，线程安全" class="headerlink" title="Vector：基于数组实现，增删慢，查询快，线程安全"></a>Vector：基于数组实现，增删慢，查询快，线程安全</h3><p>Vector的数据结构和ArrayList一样，都是基于数组实现的，不同的是Vector支持线程同步，即同一时刻只允许一个线程对Vector进行写操作（新增、删除、修改），以保证多线程环境下数据的一致性，但需要频繁地对Vector实例进行加锁和释放锁操作，因此，Vector的读写效率在整体上比ArrayList低。</p>
<h3 id="LinkedList：基于双向链表实现，增删快，查询慢，线程不安全"><a href="#LinkedList：基于双向链表实现，增删快，查询慢，线程不安全" class="headerlink" title="LinkedList：基于双向链表实现，增删快，查询慢，线程不安全"></a>LinkedList：基于双向链表实现，增删快，查询慢，线程不安全</h3><p>LinkedList还提供了在List接口中未定义的方法，用于操作链表头部和尾部的元素，因此有时可以被当作堆栈、队列或双向队列使用。</p>
<ul>
<li>ArrayBlockingQueue：基于数组数据结构实现的有界阻塞队列。</li>
<li>LinkedBlockingQueue：基于链表数据结构实现的有界阻塞队列。</li>
<li>PriorityBlockingQueue：支持优先级排序的无界阻塞队列。 </li>
<li>DelayQueue：支持延迟操作的无界阻塞队列。</li>
<li>SynchronousQueue：用于线程同步的阻塞队列。</li>
<li>LinkedTransferQueue：基于链表数据结构实现的无界阻塞队列。</li>
<li>LinkedBlockingDeque：基于链表数据结构实现的双向阻塞队列。</li>
</ul>
<p>对象的相等性在本质上是对象的HashCode值相同，Java依据对象的内存地址计算出对象的HashCode值。如果想要比较两个对象是否相等，则必须同时覆盖对象的hashCode方法和equals方法，并且hashCode方法和equals方法的返回值必须相同。</p>
<h3 id="HashSet-HashTable实现，无序"><a href="#HashSet-HashTable实现，无序" class="headerlink" title="HashSet:HashTable实现，无序"></a>HashSet:HashTable实现，无序</h3><p>HashSet存放的是散列值，它是按照元素的散列值来存取元素的。元素的散列值是通过元素的hashCode方法计算得到的，HashSet首先判断两个元素的散列值是否相等，如果散列值相等，则接着通过equals方法比较，如果equls方法返回的结果也为true, HashSet就将其视为同一个元素；如果equals方法返回的结果为false, HashSet就不将其视为同一个元素。</p>
<h3 id="TreeSet：二叉树实现"><a href="#TreeSet：二叉树实现" class="headerlink" title="TreeSet：二叉树实现"></a>TreeSet：二叉树实现</h3><p>TreeSet基于二叉树的原理对新添加的对象按照指定的顺序排序（升序、降序），每添加一个对象都会进行排序，并将对象插入二叉树指定的位置。</p>
<h3 id="LinkHashSet-HashTable实现数据存储，双向链表记录顺序"><a href="#LinkHashSet-HashTable实现数据存储，双向链表记录顺序" class="headerlink" title="LinkHashSet:HashTable实现数据存储，双向链表记录顺序"></a>LinkHashSet:HashTable实现数据存储，双向链表记录顺序</h3><h3 id="HashMap-数组-链表-红黑树存储数据（Java8，之前是数组-链表），线程不安全"><a href="#HashMap-数组-链表-红黑树存储数据（Java8，之前是数组-链表），线程不安全" class="headerlink" title="HashMap:数组+链表+红黑树存储数据（Java8，之前是数组+链表），线程不安全"></a>HashMap:数组+链表+红黑树存储数据（Java8，之前是数组+链表），线程不安全</h3><p>HashMap的key和value允许为null</p>
<p>HashMap是非线程安全的，即在同一时刻有多个线程同时写HashMap时将可能导致数据的不一致。</p>
<p>如果需要满足线程安全的条件，则可以用Collections的synchornizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p>
<p>HashMap的常用参数：</p>
<ul>
<li>capacity：当前数组的容量，默认为16，可以扩容，扩容后数组的大小为当前的两倍，因此该值始终为$2^n$</li>
<li>loadFactor:负载因子，默认为0.75</li>
<li>threshold: 扩容的阈值，其值等于caoacity*loadFactor</li>
<li>链表元素超过8个以后（并且桶的数量大于64个）HashMap会将链表结构转化为红黑树以提高查询效率（红黑树中的元素数量小于6个时转换为链表）</li>
</ul>
<h3 id="ConcurrentHashMap：分段锁实现，线程安全。"><a href="#ConcurrentHashMap：分段锁实现，线程安全。" class="headerlink" title="ConcurrentHashMap：分段锁实现，线程安全。"></a>ConcurrentHashMap：分段锁实现，线程安全。</h3><p>ConcurrnetHashMap采用分段锁的思想实现并发操作，因此是线程安全的。ConcurrentHashMap由多个Segment组成（Segment的数量也是锁的并发度），每个Segment均继承自ReentantLock并单独枷锁，所以每次进行枷锁操作时锁住的都是一个Segment，这样只要保证每个Segment都是线程安全的，也就实现了全局的线程安全。</p>
<p>ConcurrentHashMap中有个concurrencyLevel参数表示并行级别，默认是16，也就是说ConcurrnetHashMap默认由16个Segments组成，在这种情况下做多同时支持16个线程并发执行写操作，只要他们的操作分布在不同的Segment上即可。并行级别concurrnecyLevel可以在初始化时设置，一旦初始化就不可更改。</p>
<p><img src="img/ConcurrentHashMap_struct.png" alt=""></p>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>HashTable是遗留类，很多映射的常用功能都与HashMap类似，不同的是它继承自Dicitionary类，并且使线程安全的，每一时刻只能由一个线程写HashTable，并发性不如ConcurrentHashMap</p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap基于二叉树数据结构存储数据，同时实现了SortedMap接口以保障元素的顺序存取，默认按照键值的升序排序，也可以自定义排序比较器。</p>
<p>在使用TreeMap时其key必须实现Comparable接口或采用自定义的比较器，否则会抛出java.lang.ClassCastException异常。</p>
<h3 id="LinkedHashMap：基于hashTable数据结构，使用链表保存插入顺序"><a href="#LinkedHashMap：基于hashTable数据结构，使用链表保存插入顺序" class="headerlink" title="LinkedHashMap：基于hashTable数据结构，使用链表保存插入顺序"></a>LinkedHashMap：基于hashTable数据结构，使用链表保存插入顺序</h3><p>在通过Iterator遍历LinkedhashMap时，会按照元素的插入顺序访问元素。</p>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>java中Throwable是所有错误或异常的父类，Throwable又可分为Error和Exception。</p>
<p>常见的Error有：AWTError、ThreadDeath。</p>
<p>Exception又可分为RuntimeException和CheckedException</p>
<p><img src="img/ExceptionAndError.png" alt=""></p>
<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p>指Java程序运行错误，如果程序在启动时出现Error，则启动失败；如果程序在运行过程中出现Error，则系统将退出进程。</p>
<p>出现Error通常是因为系统的内部错误或资源耗尽，Error不能被在运行过程中被动态处理。如果程序出现Error，则系统能做的工作也只能有记录错误的成因和安全终止。</p>
<h1 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h1><p>Exception指Java程序运行异常，即运行中的程序发生了人们不期望发生的事件，可以被Java异常处理机制处理。Exception也是程序开发中异常处理的核心，可分为RuntimeException（运行时异常）和CheckedException（检查异常）</p>
<p><img src="img/Exception.png" alt=""></p>
<ul>
<li>RuntimeException：指在Java虚拟机正常运行期间抛出的异常，RuntimeException可以被捕获并处理，如果出现RuntimeException，那么一定是程序发生错误导致的。我们通常需要抛出该异常或者捕获并处理该异常。常见的RuntimeException有NullPointerException、ClassCastException、ArrayIndexOutOfBundsException等。</li>
</ul>
<ul>
<li>CheckedException：指在编译阶段Java编译器会检查CheckedException异常并强制程序捕获和处理此类异常，即要求程序在可能出现异常的地方通过try catch语句块捕获并处理异常。常见的CheckedException有由于I/O错误导致的IOException、SQLException、ClassNotFoundException等。该类异常一般由于打开错误的文件、SQL语法错误、类不存在等引起。</li>
</ul>
<h2 id="异常处理方式：抛出异常、使用try-catch-捕获并处理异常"><a href="#异常处理方式：抛出异常、使用try-catch-捕获并处理异常" class="headerlink" title="异常处理方式：抛出异常、使用try catch 捕获并处理异常"></a>异常处理方式：抛出异常、使用try catch 捕获并处理异常</h2><p>（1）抛出异常：遇到异常时不进行具体处理，而是将异常抛给调用者，由调用者根据情况处理。有可能是直接捕获并处理，也有可能是继续向上层抛出异常。抛出异常有三种形式：throws、throw、系统自动抛出异常。</p>
<p>（2）使用try catch捕获并处理异常：使用trycatch捕获异常能够有针对性地处理每种可能出现的异常，并在捕获到异常后根据不同的情况做不同的处理。其使用过程比较简单：用try catch语句块将可能出现异常的代码包起来即可。</p>
<h2 id="throw-和-throws的区别"><a href="#throw-和-throws的区别" class="headerlink" title="throw 和 throws的区别"></a>throw 和 throws的区别</h2><p>throw和throws的区别如下。</p>
<ul>
<li>位置不同：throws作用在方法上，后面跟着的是异常的类；而throw作用在方法内，后面跟着的是异常的对象。</li>
<li>功能不同：throws用来声明方法在运行过程中可能出现的异常，以便调用者根据不同的异常类型预先定义不同的处理方式；throw用来抛出封装了异常信息的对象，程序在执行到throw时后续的代码将不再执行，而是跳转到调用者，并将异常信息抛给调用者。也就是说，throw后面的语句块将无法被执行（finally语句块除外）。</li>
</ul>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>反射机制指在程序运行过程中，对任意一个类都能获取其所有属性和方法，并且对任意一个对象都能调用其任意一个方法。这种动态获取类和对象的信息，以及动态调用对象的方法的功能被称为Java语言的反射机制。</p>
<p>从反射的角度来说，Java属于半动态语言。</p>
<h2 id="Java反射的API"><a href="#Java反射的API" class="headerlink" title="Java反射的API"></a>Java反射的API</h2><p>Java的反射API主要用于在运行过程中动态生成类、接口或对象等信息，其常用API如下。</p>
<ul>
<li>Class类：用于获取类的属性、方法等信息。</li>
<li>Field类：表示类的成员变量，用于获取和设置类中的属性值。</li>
<li>Method类：表示类的方法，用于获取方法的描述信息或者执行某个方法。</li>
<li>Constructor类：表示类的构造方法。</li>
</ul>
<h2 id="反射的步骤"><a href="#反射的步骤" class="headerlink" title="反射的步骤"></a>反射的步骤</h2><p>（1）获取想要操作的类的Class对象，该Class对象是反射的核心，通过它可以调用类的任意方法。</p>
<p>（2）调用Class对象所对应的类中定义的方法，这是反射的使用阶段。</p>
<p>（3）使用反射API来获取并调用类的属性和方法等信息。</p>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>Java中的内部类根据定义方式的不同可分为：<br>静态内部类、成员内部类、局部内部类和匿名内部类</p>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>定义在类内部的静态类被称为静态内部类</p>
<p>静态内部类可以访问外部类的静态变量和方法；在静态内部类中可以定义静态变量、方法、构造函数等；静态内部类通过“外部类．静态内部类”的方式来调用</p>
<p>和外部类关系密切且不依赖外部类实例的类，可以使用静态内部类实现。</p>
<h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>定义在类内部的非静态类叫作成员内部类，成员内部类不能定义静态方法和变量（final修饰的除外），因为成员内部类是非静态的，而在Java的非静态代码块中不能定义静态方法和变量。</p>
<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>定义在方法中的类叫作局部内部类</p>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>匿名内部类指通过继承一个父类或者实现一个接口的方式直接定义并使用的类。匿名内部类没有class关键字，这是因为匿名内部类直接使用new生成一个对象的引用</p>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>泛型的本质是参数化类型，泛型提供了编译时类型的安全检测机制，该机制允许程序在编译时检测非法的类型。</p>
<p>而使用泛型的好处是在编译期就能够检查类型是否安全，同时所有强制性类型转换都是自动和隐式进行的，提高了代码的安全性和重用性。</p>
<h2 id="泛型标记和泛型限定：E、T、K、V、N、"><a href="#泛型标记和泛型限定：E、T、K、V、N、" class="headerlink" title="泛型标记和泛型限定：E、T、K、V、N、?"></a>泛型标记和泛型限定：E、T、K、V、N、?</h2><p><img src="img/gen_type.png" alt=""></p>
<p>在使用泛型的时候，若希望将类的继承关系加入泛型应用中，就需要对泛型做限定，具体的泛型限定有对泛型上线的限定和对泛型下线的限定。</p>
<h2 id="对泛型上限的限定：-lt-extendsT-gt"><a href="#对泛型上限的限定：-lt-extendsT-gt" class="headerlink" title="对泛型上限的限定：&lt;? extendsT&gt;"></a>对泛型上限的限定：&lt;? extendsT&gt;</h2><p>在Java中使用通配符“? ”和“extends”关键字指定泛型的上限，具体用法为&lt;? extends T&gt;，它表示该通配符所<strong>代表的类型是T类的子类或者接口T的子接口。</strong></p>
<h2 id="对泛型下限的限定：-lt-super-T-gt"><a href="#对泛型下限的限定：-lt-super-T-gt" class="headerlink" title="对泛型下限的限定：&lt;? super T&gt;"></a>对泛型下限的限定：&lt;? super T&gt;</h2><p>在Java中使用通配符“? ”和“super”关键字指定泛型的下限，具体用法为&lt;? super T&gt;，它表示该通配符所<strong>代表的类型是T类型的父类或者父接口。</strong></p>
<h2 id="泛型类、泛型接口、泛型方法"><a href="#泛型类、泛型接口、泛型方法" class="headerlink" title="泛型类、泛型接口、泛型方法"></a>泛型类、泛型接口、泛型方法</h2><h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>在编码阶段采用泛型时加上的类型参数，会被编译器在编译时去掉，这个过程就被称为类型擦除。因此，泛型主要用于编译阶段。在编译后生成的Java字节代码文件中不包含泛型中的类型信息</p>
<p>Java类型的擦除过程为：首先，查找用来替换类型参数的具体类（该具体类一般为Object），如果指定了类型参数的上界，则以该上界作为替换时的具体类；然后，把代码中的类型参数都替换为具体的类。</p>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>在使用Java序列化技术保存对象及其状态信息时，对象及其状态信息会被保存在一组字节数组中，在需要时再将这些字节数组反序列化为对象。注意，对象序列化保存的是对象的状态，即它的成员变量，因此类中的静态变量不会被序列化。</p>
<h2 id="Java序列化的注意事项"><a href="#Java序列化的注意事项" class="headerlink" title="Java序列化的注意事项"></a>Java序列化的注意事项</h2><ul>
<li>类要实现序列化功能，只需实现java.io.Serializable接口即可。</li>
<li>序列化和反序列化必须保持序列化的ID一致，一般使用private static final longserialVersionUID定义序列化ID。</li>
<li>序列化并不保存静态变量。</li>
<li>使用Transient关键字可以阻止该变量被序列化，在被反序列化后，transient变量的值被设为对应类型的初始值</li>
</ul>
<p><strong>transient修饰的属性和static修饰的静态属性不会被序列化。</strong></p>
<p>可以基于JDK原生的ObjectOutputStream和ObjectInputStream类实现对象进行序列化及反序列化，并调用其writeObject和readObject方法实现自定义序列化策略。</p>
<h1 id="Java线程创建的方式"><a href="#Java线程创建的方式" class="headerlink" title="Java线程创建的方式"></a>Java线程创建的方式</h1><p>常见的Java线程的4种创建方式分别为：</p>
<ul>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
<li>通过ExecutorService实现有返回值的线程、基于线程池</li>
<li>Callable<Class>实现有返回值的线程、基于线程池</li>
</ul>
<h2 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h2><p>Thread类实现了Runnable接口并定义了操作线程的一些方法，我们可以通过继承Thread类的方式创建一个线程。</p>
<p>start方法是一个native方法，通过在操作系统上启动一个新线程，并最终执行run方法来启动一个线程。</p>
<h2 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h2><p>基于Java编程语言的规范，如果子类已经继承（extends）了一个类，就无法再直接继承Thread类，此时可以通过实现Runnable接口创建线程。</p>
<p>事实上，在传入一个实现了Runnable的线程实例target给Thread后，Thread的run方法在执行时就会调用target.run方法并执行该线程具体的实现逻辑。</p>
<h2 id="通过ExecutorService和Callable实现有返回值的线程"><a href="#通过ExecutorService和Callable实现有返回值的线程" class="headerlink" title="通过ExecutorService和Callable实现有返回值的线程"></a>通过ExecutorService和Callable<Class>实现有返回值的线程</h2><p>有时，我们需要在主线程中开启多个线程并发执行一个任务，然后收集各个线程执行返回的结果并将最终结果汇总起来，这时就要用到Callable接口。</p>
<p>实现方式：创建一个类并实现Callable接口，在call方法中实现具体的运算逻辑并返回计算结果。具体的调用过程为：创建一个线程池、一个用于接收返回结果的Future List及Callable线程实例，使用线程池提交任务并将线程执行之后的结果保存在Future中，在线程执行结束后遍历FutureList中的Future对象，在该对象上调用get方法就可以获取Callable线程任务返回的数据并汇总结果</p>
<h2 id="基于线程池"><a href="#基于线程池" class="headerlink" title="基于线程池"></a>基于线程池</h2><p>线程是非常宝贵的计算资源，在每次需要时创建并在运行结束后销毁是非常浪费资源的。我们可以使用缓存策略并使用线程池来创建线程</p>
<h1 id="线程池的工作原理"><a href="#线程池的工作原理" class="headerlink" title="线程池的工作原理"></a>线程池的工作原理</h1><p><strong>JVM先根据用户的参数创建一定数量的可运行的线程任务，并将其放入队列中，在线程创建后启动这些任务，如果线程数量超过了最大线程数量（用户设置的线程池大小），则超出数量的线程排队等候，在有任务执行完毕后，线程池调度器会发现有可用的线程，进而再次从队列中取出任务并执行。</strong></p>
<p>线程池的主要作用是线程复用、线程资源管理、控制操作系统的最大并发数，以保证系统高效（通过线程资源复用实现）且安全（通过控制最大线程并发数实现）地运行。</p>
<h2 id="线程复用"><a href="#线程复用" class="headerlink" title="线程复用"></a>线程复用</h2><p>在start方法中不断循环调用传递进来的Runnable对象，程序就会不断执行run方法中的代码，可以将在循环方法中不断获取的Runnable对象存放在Queue中，当前线程在获取下一个Runnable对象之前可以是阻塞的，这样既能有效控制正在执行的线程个数，也能保证系统中正在等待执行的其他线程有序执行。这样就简单实现了一个线程池，达到了线程复用的效果。</p>
<h2 id="线程池的核心组件和核心类"><a href="#线程池的核心组件和核心类" class="headerlink" title="线程池的核心组件和核心类"></a>线程池的核心组件和核心类</h2><ul>
<li>线程池管理器：用于创建并管理线程池。</li>
<li>工作线程：线程池中执行具体任务的线程</li>
<li>任务接口：用于定义工作线程的调度和执行策略，只有线程实现了该接口，线程中的任务才能够被线程池调度。</li>
<li>任务队列：存放待处理的任务，新的任务将会不断被加入队列中，执行完成的任务将被从队列中移除。</li>
</ul>
<p>Java中的线程池是通过Executor框架实现的，在该框架中用到了Executor、Executors、ExecutorService、ThreadPoolExecutor、Callable、Future、FutureTask这几个核心类</p>
<p><img src="img/ThreadPool.png" alt=""></p>
<h2 id="Java线程池的工作流程"><a href="#Java线程池的工作流程" class="headerlink" title="Java线程池的工作流程"></a>Java线程池的工作流程</h2><p>Java线程池的工作流程为：线程池刚被创建时，只是向系统申请一个用于执行线程队列和管理线程池的线程资源。在调用execute()添加一个任务时，线程池会按照以下流程执行任务。</p>
<ul>
<li>如果正在运行的线程数量少于corePoolSize（用户定义的核心线程数），线程池就会立刻创建线程并执行该线程任务。</li>
<li>如果正在运行的线程数量大于等于corePoolSize，该任务就将被放入阻塞队列中。</li>
<li>在阻塞队列已满且正在运行的线程数量少于maximumPoolSize时，线程池会创建非核心线程立刻执行该线程任务。</li>
<li>在阻塞队列已满且正在运行的线程数量大于等于maximumPoolSize时，线程池将拒绝执行该线程任务并抛出RejectExecutionException异常。</li>
<li>在线程任务执行完毕后，该任务将被从线程池队列中移除，线程池将从队列中取下一个线程任务继续执行。</li>
<li>在线程处于空闲状态的时间超过keepAliveTime时间时，正在运行的线程数量超过corePoolSize，该线程将会被认定为空闲线程并停止。因此在线程池中所有线程任务都执行完毕后，线程池会收缩到corePoolSize大小。</li>
</ul>
<p><img src="img/thread_pool_proc.png" alt=""></p>
<h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h2><p>为了保证操作系统的安全，线程池将通过拒绝策略处理新添加的线程任务。JDK内置的拒绝策略有AbortPolicy、CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy这4种，默认的拒绝策略在ThreadPoolExecutor中作为内部类提供。</p>
<ol>
<li>AbortPolicyAbortPolicy直接抛出异常，阻止线程正常运行</li>
<li>CallerRunsPolicy如果被丢弃的线程任务未关闭，则执行该线程任务。注意，CallerRunsPolicy拒绝策略不会真的丢弃任务。</li>
<li>DiscardOldestPolicy的拒绝策略为：移除线程队列中最早的一个线程任务，并尝试提交当前任务。</li>
<li>DiscardPolicy的拒绝策略为：丢弃当前的线程任务而不做任何处理。如果系统允许在资源不足的情况下丢弃部分任务，则这将是保障系统安全、稳定的一种很好的方案。</li>
<li>自定义拒绝策略：以上4种拒绝策略均实现了RejectedExecutionHandler接口，若无法满足实际需要，则用户可以自己扩展RejectedExecutionHandler接口来实现拒绝策略，并捕获异常来实现自定义拒绝策略</li>
</ol>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-02-05</span><i class="fa fa-tag"></i><a class="tag" href="/tags/java/" title="java">java </a><span class="leancloud_visitors"></span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2021/02/05/java知识点/,Vector,java知识点,;" target="_blank" rel="noopener"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2021/02/06/%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E7%82%B9%E6%95%B0/" title="可获得的最大点数">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2021/02/05/%E6%9F%A5%E8%AF%A2%E5%B8%A6%E9%94%AE%E7%9A%84%E6%8E%92%E5%88%97/" title="查询带键的排列">下一篇</a></li></ul></div><script src="/js/visitors.js"></script><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@latest/dist/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:false|| false, 
  app_id:'',
  app_key:'',
  placeholder:'念念不忘，必有回响...',
  path: window.location.pathname,
  serverURLs: '',
  visitor:true,
  recordIP:true,
  avatar:'mp'
})</script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/js/baidu-tongji.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":200,"height":350},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body></html>