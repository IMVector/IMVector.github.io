<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Vector"><title>Java文件与流 · Vector</title><meta name="description" content="MathJax.Hub.Config({
tex2jax: {
  inlineMath: [['$','$'], ['\\(','\\)']],
  processEscapes: true
  }
});






来源文献


Java输入、输入、IO流 类层次关系梳理


原文作者：墨染草"><meta name="keywords" content="Vector的小窝"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Vector</a></h3><div class="description"><p>没人扶你的时候，自己要站直，路还长，背影要美！</p></div></div></div><ul class="social-links"><li><a href="https://github.com/IMVector" target="_blank" rel="noopener"><i class="fa fa-github"></i></a></li><li><a href="mailto:1769326712@qq.com"><i class="fa fa-envelope"></i></a></li><li><a href="http://sighttp.qq.com/authd?IDKEY=" target="_blank" rel="noopener"><i class="fa fa-qq"></i></a></li><li><a href="https://zhihu.com/people/" target="_blank" rel="noopener"><i class="fa fa-mortar-board"></i></a></li></ul><div class="footer"><div class="p"> <span>© 2017 - 2020 </span><i class="fa fa-star"></i><span> Vector</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><a href="https://github.com/mrcore/hexo-theme-Anatole-Core" target="_blank">Anatole-Core.  </a><span> &</span><a href="https://github.com/IMVector/blog_vector" target="_blank">Vector.  </a><a href="http://www.beian.miit.gov.cn/" target="_blank">&nbsp;粤ICP备15011643号</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">标签</a></li><li><a href="/about">关于</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Java文件与流</a></h3></div><div class="post-content"><!--将该代码放入博客模板的head中即可-->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
  inlineMath: [['$','$'], ['\\(','\\)']],
  processEscapes: true
  }
});
</script>
<!--latex数学显示公式-->
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


<blockquote>
<p>来源文献</p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/LittleHann/p/3678685.html" target="_blank" rel="noopener">Java输入、输入、IO流 类层次关系梳理</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.jianshu.com/p/ac8d51a50aa7" target="_blank" rel="noopener">原文作者：墨染草简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</a></p>
</blockquote>
<blockquote>
<p>《java变成的逻辑》</p>
</blockquote>
<h3 id="1-按照用途进行分类"><a href="#1-按照用途进行分类" class="headerlink" title="1. 按照用途进行分类"></a>1. 按照用途进行分类</h3><p>1.1 按照数据的来源（去向）分类</p>
<ul>
<li>是文件：FileInputStream, FileOutputStream, FileReader, FileWriter</li>
<li>是byte[]：ByteArrayInputStream, ByteArrayOutputStream</li>
<li>是char[]：CharArrayReader, CharArrayWriter</li>
<li>是String：StringBufferInputStream(已过时，因为其只能用于String的每个字符都是8位的字符串), StringReader, StringWriter</li>
<li>是网络数据流：InputStream, OutputStream, Reader, Writer</li>
</ul>
<p>1.2 按照格式化输出</p>
<ul>
<li>需要格式化输出：PrintStream（输出字节），PrintWriter（输出字符）</li>
</ul>
<p>1.3 按缓冲功能分</p>
<ul>
<li>要缓冲：BufferedInputStream, BufferedOuputStream, BuffereaReader, BufferedWriter</li>
</ul>
<p>1.4 按照数据格式分</p>
<ul>
<li>二进制格式（只要确定不是纯文本格式的），InputStream, OutputStream, 及其所有带Stream子类</li>
<li>纯文本格式（比如英文/汉字/或其他编码文字）：Reader, Writer, 及其相关子类</li>
</ul>
<p>1.5 按照输入输出分</p>
<ul>
<li>输入：Reader， InputStream，及其相关子类</li>
<li>输出：Writer，OutputStream，及其相关子类</li>
</ul>
<p>1.6 特殊需求</p>
<ul>
<li>从Stream转化为Reader，Writer：InputStreamReader，OutputStreamWriter</li>
<li>对象输入输出流：ObjectInputStream，ObjectOutputStream</li>
<li>进程间通信：PipeInputStream，PipeOutputStream，PipeReader，PipeWriter</li>
<li>合并输入：SequenceInputStream</li>
<li>更特殊的需要：PushbackInputStream, PushbackReader, LineNumberInputStream, LineNumberReader</li>
</ul>
<h3 id="2-确定选用流对象的步骤"><a href="#2-确定选用流对象的步骤" class="headerlink" title="2 确定选用流对象的步骤"></a>2 确定选用流对象的步骤</h3><p>•确定原始数据的格式</p>
<ul>
<li>确定是输入还是输出</li>
<li>是否需要转换流</li>
<li>数据的来源（去向）</li>
<li>是否需要缓冲</li>
<li>是否需要格式化输出</li>
</ul>
<h3 id="3-Java中Inputstream-OutputStream与Reader-Writer的区别"><a href="#3-Java中Inputstream-OutputStream与Reader-Writer的区别" class="headerlink" title="3 Java中Inputstream/OutputStream与Reader/Writer的区别"></a>3 Java中Inputstream/OutputStream与Reader/Writer的区别</h3><p>•Reader/Writer和InputStream/OutputStream分别是I/O库提供的两套平行独立的等级机构，</p>
<ul>
<li>InputStream、OutputStream是用来处理8位元(<strong><em>字节\</em></strong>)的流，也就是用于读写ASCII字符和二进制数据；</li>
<li>Reader、Writer是用来处理16位元的流，也就是用于读写Unicode编码的字符。</li>
<li>在JAVA语言中，byte类型是8位的，char类型是16位的，所以在处理中文的时候需要用Reader和Writer。</li>
<li>两种等级机构下，有一道桥梁InputStreamReader、OutputStreamWriter负责进行InputStream到Reader的适配和由OutputStream到Writer的适配。</li>
</ul>
<p>•在Java中，有不同类型的Reader/InputStream输入流对应于不同的数据源：</p>
<ul>
<li>FileReader/FileInputStream 用于从文件输入；</li>
<li>CharArrayReader/ByteArrayInputStream 用于从程序中的字符数组输入；</li>
<li>StringReader/StringBufferInputStream 用于从程序中的字符串输入；</li>
<li>PipedReader/PipeInputStream 用于读取从另一个线程中的数据PipedWriter/PipeOutputStream 写入管道的数据。</li>
<li>相应的也有不同类型的Writer/OutputStream输出流对应于不同的数据源：FileWriter/FileOutputStream，CharArrayWriter/ByteArrayOutputStream，StringWriter，PipeWriter/PipedOutputStream。</li>
</ul>
<p>•有两种没有对应Reader类型的InputStream输入流，用getInputStream()来读取数据。</p>
<ul>
<li>Socket 用于套接字；</li>
<li>URLConnection 用于 URL 连接。</li>
</ul>
<h3 id="4-流类的继承关系图"><a href="#4-流类的继承关系图" class="headerlink" title="4  流类的继承关系图"></a>4  流类的继承关系图</h3><p><img src="img/InputStream.png" alt="img"></p>
<p><img src="img/OutputStream.png" alt="下载"></p>
<p><img src="img/Reader.png" alt="img"></p>
<p><img src="img/Writer.png" alt="img"></p>
<p>4.1 .继承自InputStream/OutputStream的流都是用于向程序中输入/输出数据，且数据的单位都是字节(byte=8bit)</p>
<p>4.2 .继承自Reader/Writer的流都是用于向程序中输入/输出数据，且数据的单位都是字符(2byte=16bit)</p>
<p>4.3 节点流类型</p>
<ul>
<li>对文件操作的字符流有FileReader/FileWriter，</li>
<li>字节流有FileInputStream/FileOutputStream。</li>
</ul>
<p>4.4 处理流类型</p>
<ul>
<li>缓冲流：缓冲流要“套接”在相应的节点流之上，对读写的数据提供了缓冲的功能，提高了读写效率，同事增加了一些新的方法。</li>
<li>字节缓冲流有BufferedInputStream/BufferedOutputStream，字符缓冲流有BufferedReader/BufferedWriter，字符缓冲流分别提供了读取和写入一行的方法ReadLine和NewLine方法。</li>
<li>对于输出地缓冲流，写出的数据，会先写入到内存中，再使用flush方法将内存中的数据刷到硬盘。所以，在使用字符缓冲流的时候，一定要先flush，然后再close，避免数据丢失。</li>
</ul>
<p><strong>•转换流：用于字节数据到字符数据之间的转换。</strong></p>
<ul>
<li>字符流InputStreamReader/OutputStreamWriter。其中，InputStreamReader需要与InputStream“套接”，OutputStreamWriter需要与OutputStream“套接”。</li>
</ul>
<p><strong>•数据流：提供了读写Java中的基本数据类型的功能。</strong></p>
<ul>
<li>DataInputStream和DataOutputStream分别继承自InputStream和OutputStream，需要“套接”在InputStream和OutputStream类型的节点流之上。</li>
</ul>
<p><strong>•对象流：用于直接将对象写入写出。</strong></p>
<ul>
<li>流类有ObjectInputStream和ObjectOutputStream，本身这两个方法没什么，但是其要写出的对象有要求，该对象必须实现Serializable接口，来声明其是可以序列化的。否则，不能用对象流读写。</li>
</ul>
<p>Java IO的基本类大多位于java.io包中。类InputStream表示输入流，OutputStream表示输出流，而FileInputStream表示文件输入流，FileOutputStream表示文件输出流。</p>
<h3 id="InputStream和OutputStream"><a href="#InputStream和OutputStream" class="headerlink" title="InputStream和OutputStream"></a>InputStream和OutputStream</h3><p>一些实际上不是IO数据源也转换成了流，以方便参与流的协作，比如字节数组，也包装了流ByteArrayInputStream和ArrayOutputStream</p>
<p>基本的流按字节读写没有缓冲区，这不方便使用。java解决这个问题的方法是使用装饰器设计模式，引入很多装饰类，对基本的流增加功能，以方便使用。</p>
<p>java中有很多装饰器类，有两个积累，过滤器输入流FilterInputStream和过滤器输出流FilterOutputStream。</p>
<p>其相关的一些子类有（枚举其中一部分）：</p>
<ol>
<li>对流其缓冲装饰的子类是BufferedInputStream和BufferedOutputStream</li>
<li>可以按8种基本类型和字符串进行读写的子类是DataInputStream和DataOutputStream</li>
<li>可以对流进行压缩和解压缩的子类有GZIPInputStream、ZipInputStream、GZIPOutputStream和ZipOutputStream</li>
<li>可以将基本类型、对象输出为其字符串表示的子类有PrintStream</li>
</ol>
<h3 id="Reader和Writer"><a href="#Reader和Writer" class="headerlink" title="Reader和Writer"></a>Reader和Writer</h3><p><strong>以InputStram/OutputStream为基类的流基本都是以二进制形式处理数据的，不能够方便地处理文本文件，没有编码地概念，能够方便地按字符处理文本数据的类是Reader和Writer</strong>，它的子类：</p>
<ol>
<li>读写文件的子类是FileReader和FileWriter</li>
<li>其缓冲装饰地子类是BufferedReader和BufferedWriter</li>
<li>将字符串数组包装为Reader/Writer的子类是CharArrayReader和CharArrayWriter</li>
<li>将字符串包装为Reader/Writer的子类是StringReader和StringWriter</li>
<li>将InputStream/OutputStream转换为Reader/Writer的子类是InputStreamReader和OutputStreamWriter</li>
<li>将基本类型、对象输出为其字符串表示的子类是PrintWriter</li>
</ol>
<h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h3><p><strong>Java主要通过接口Serializable和类ObjectInputStream/ObjectOutputStream提供对序列化的支持</strong>，基本的使用是比较简单的，但也有一些复杂的地方。不过，Java的默认序列化有一些缺点，比如，序列化后的形式比较大、浪费空间，序列化/反序列化的性能也比较低，更重要的问题是，它是Java特有的技术，不能与其他语言交互。</p>
<p>XML是前几年最为流行的描述结构性数据的语言和格式，Java对象也可以序列化为XML格式。XML容易阅读和编辑，且可以方便地与其他语言进行交互。XML强调格式化但比较“笨重”，JSON是近几年来逐渐流行的轻量级的数据交换格式，在很多场合替代了XML，也非常容易阅读和编辑。Java对象也可以序列化为JSON格式，且与其他语言进行交互。</p>
<p>XML和JSON都是文本格式，人容易阅读，但占用的空间相对大一些，在只用于网络远程调用的情况下，有很多流行的、跨语言的、精简且高效的对象序列化机制，如ProtoBuf、Thrift、MessagePack等。其中，MessagePack是二进制形式的JSON，更小更快。</p>
<h2 id="二进制文件与字节流"><a href="#二进制文件与字节流" class="headerlink" title="二进制文件与字节流"></a>二进制文件与字节流</h2><p>本节介绍在Java中如何以二进制字节的方式来处理文件，前面我们提到Java中有流的概念，以二进制方式读写的主要流有:</p>
<ul>
<li><p>InputStream/OutputStream:这是基类，它们是抽象类。</p>
</li>
<li><p>FileInputStream/FileOutputStream:输入源和输出目标是文件的流。</p>
</li>
<li><p>ByteArrayInputStream/ByteArrayOutputStream:输入源和输出目标是字节数组的流。</p>
</li>
<li><p>DataInputStream/DataOutputStream:装饰类，按基本类型和字符串而非只是字节读写流。</p>
</li>
<li><p>BufferedInputStream/BufferedOutputStream:装饰类，对输入输出流提供缓冲功能。</p>
</li>
</ul>
<h3 id="InputStream字节输入流（抽象类）"><a href="#InputStream字节输入流（抽象类）" class="headerlink" title="InputStream字节输入流（抽象类）"></a>InputStream字节输入流（抽象类）</h3><p>InputStream是抽象类，主要方法是:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>
<p>read方法从流中读取下一个字节，返回类型为int，但取值为0~255，当读到流结尾的时候，返回值 为-1，如果流中没有数据，read方法会阻塞直到数据到来、流关闭或异常出现。异常出现时，read方法抛出异常，类型为IOException，这是一个受检异常，调用者必须进行处理。read是一个抽象方法，具体子类必须实现，FileInputStream会调用本地方法。所谓本地方法，一般不是用Java写的，大多使用C语言实现，具体实现往往与虚拟机和操作系统有关。</p>
<p>InputStream中一次读入多个字节的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>

<p>读入的字节放入参数数组b中，第一个字节存入b[0]，第二个存入b[1]，以此类推，一次最多读入的字节个数为数组b的长度，但实际读入的个数可能小于数组长度，返回值为实际读入的字节个数。如果刚开始读取时已到流结尾，则返回-1;否则，只要数组长度大于0，该方法都会尽力至少读取一个字节，如果流中一个字节都没有，它会阻塞，异常出现时也是抛出IOException。该方法不是抽象方法，InputStream有一个默认实现，主要就是循环调用读一个字节的read方法，但子类如FileInputStream往往会提供更为高效的实现。</p>
<p>批量读取还有一个更为通用的重载方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>

<p>读入的第一个字节放入b[off]，最多读取len个字节，read(byte b[])就是调用了该方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123; <span class="keyword">return</span> read(b, <span class="number">0</span>, b.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流读取结束后，应该关闭，以释放相关资源，关闭方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream input = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        input = <span class="keyword">new</span> FileInputStream(<span class="string">"src/readme.txt"</span>);</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123; <span class="comment">// 利用while同时读取并判断</span></span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (input != <span class="keyword">null</span>) &#123; input.close(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不管read方法是否抛出了异常，都应该调用close方法，所以close方法通常应该放在finally语旬内。<strong>close方法自己可能也会抛出IOException，但通常可以捕获并忽略。</strong></p>
<p>InputStream的相关高级方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function"><span class="comment">// skip跳过输入流中n个字节，因为输入流中剩余的字节个数可能不到n，</span></span></span><br><span class="line"><span class="function"><span class="comment">// 所以返回值为实际略过的字节个数。InputStream的默认实现就是尽力读取n个字节并扔掉，子类往往会提供更为高效的实现， </span></span></span><br><span class="line"><span class="function"><span class="comment">// FileInputStream会调用本地方法。在处理数据时，对于不感兴趣的部分，skip往往比读取然后扔掉的效率要高。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function"><span class="comment">// available返回下一次不需要阻塞就能读取到的大概字节个数。</span></span></span><br><span class="line"><span class="function"><span class="comment">// InputStream的默认实现是返回0，子类会根据具体情况返回适当的值，FileInputStream会调用本地方法。</span></span></span><br><span class="line"><span class="function"><span class="comment">// 在文件读写中，这个方法一般没什么用，但在从网络读取数据时，可以根据该方法的返回值在网络有足够数据时才读，以避免阻塞。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readlimit)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>

<p>InputStream定义了三个方法：mark、reset、markSupported，用于支持从读过的流中重复读取。怎么重复读取呢？先使用mark()方法将当前位置标记下来，在读取了一些字节，希望重新从标记位置读时，调用reset方法。能够重复读取不代表能够同到任意的标记位置，mark方法有一个参数readLimit，表示在设置了标记后，能够继续往后读的最多字节数，如果超过了，标记会无效。为什么会这样呢？因为之所以能够重读，是因为流能够将从标记位置开始的字节保存起来，而保存消耗的内存不能无限大，流只保证不会小于readLimit。</p>
<p>不是所有流都支持mark、reset方法，是否支持可以通过markSupported的返同值进行判断。InpuStream的默认实现是不支持，FileInputStream也不直接支持，但BufferedInput-Stream和ByteArrayInputStream可以支持。</p>
<h3 id="OutputStream字节输出流（抽象类）"><a href="#OutputStream字节输出流（抽象类）" class="headerlink" title="OutputStream字节输出流（抽象类）"></a>OutputStream字节输出流（抽象类）</h3><p>OutputStream的基本方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<p>向流中写入一个字节，参数类型虽然是int，但其实只会用到最低的8位。这个方法是抽象方法，具体子类必须实现，FileInputStream会调用本地方法。</p>
<p>OutputStream还有两个批量写入的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">`</span></span><br></pre></td></tr></table></figure>


<p>在第二个方法中，第一个写入的字节是<code>b[off]</code>，写入个数为<code>len</code>，最后一个是<code>b[off+len-1]</code>，第一个方法等同于调用<code>write(b，0，b.length);</code>。OutputStream的默认实现是循环调用单字节的<code>write()</code>方法，子类往往有更为高效的实现，FileOutpuStream会调用对应的批量写本地方法。</p>
<p>OutputStream还有两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>

<p>flush方法将缓冲而未实际写的数据进行实际写入，比如，在BufferedOutputStream中，调用flush方法会将其缓冲区的内容写到其装饰的流中，并调用该流的flush方法。基类OutputStream没有缓冲，flush方法代码为空。</p>
<p>需要说明的是文件输出流FileOutputStream，你可能会认为，调用flush方法会强制确保数据保存到硬盘上，但实际上不是这样，FileOutputStream没有缓冲，没有重写flush方法，调用flush方法没有任何效果，数据只是传递给了操作系统，但操作系统什么时候保存到硬盘上，这是不一定的。要确保数据保存到了硬盘上，可以调用FileOutputStream中的特有方法，具体待会介绍。</p>
<p>close方法一般会首先调用flush方法，然后再释放流占用的系统资源。同InputStream一样，close方法一般应该放在finally语旬内。</p>
<h3 id="FileInputStream-和-FileOutputStream"><a href="#FileInputStream-和-FileOutputStream" class="headerlink" title="FileInputStream 和 FileOutputStream"></a>FileInputStream 和 FileOutputStream</h3><p>FileInputStream和FileOutputStream的输入源和输出目标是文件</p>
<p>FileOutputStream的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(File file, <span class="keyword">boolean</span> append)</span> <span class="keyword">throws</span> FileNotFoundException <span class="comment">// 是否允许追加</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException <span class="comment">// 路径可以是绝对路径，也可以是相对路径</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 如果文件已存在，append参数指定是追加还是覆盖，</span></span></span><br><span class="line"><span class="function"><span class="comment">// true表示追加，false表示覆盖，第二个构造方法没有append参数，表示覆盖。</span></span></span><br></pre></td></tr></table></figure>

<p>new一个FileOutputStream对象会实际打开文件，操作系统会分配相关资源。如果当前用户没有写权限，会抛出异常SecurityException，它是一种RuntimeException。如果指定的文件是一个已存在的目录，或者由于其他原因不能打开文件，会抛出异常FileNotFoundException，它是 IOException的一个子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"hello.txt"</span>); </span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    String data = <span class="string">"hello, 123"</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = data.getBytes(Charset.forName(<span class="string">"UTF-8"</span>)); output.write(bytes);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    output.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OutputStream只能以byte或byte数组写文件，为了写字符串，我们调用String的get-Bytes方法得到它的 UTF-8编码的字节数组，再调用write()方法，写的过程放在try语旬内，在finally语旬中调用close方法。</p>
<p>两个额外方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FileChannel <span class="title">getChannel</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> FileDescriptor <span class="title">getFD</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>FileChannel定义在java.nio中，表示文件通道概念。FileChannel中有一个sync()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span> <span class="keyword">throws</span> SyncFailedException</span>;</span><br></pre></td></tr></table></figure>
<p>这是一个本地方法，它会确保将操作系统缓冲的数据写到硬盘上。注意与Output-Stream的flush方法相区别，flush方法只能将应用程序缓冲的数据写到操作系统，sync方法则确保数据写到硬盘，不过一般情况下，我们并不需要手工调用它，只要操作系统和硬件设备没问题，数据迟早会写入。在一定特定情况下，一定需要确保数据写入硬盘，则可以调用该方法。</p>
<p>FileInputStream的构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException</span></span><br></pre></td></tr></table></figure>

<p>参数与FileOutputStream类似，可以是文件路径或File对象，但必须是一个已存在的文件，不能是目录。new一个FileInputStream对象也会实际打开文件，操作系统会分配相关资源，如果文件不存在，会抛出异常FileNotFoundException，如果当前用户没有读的权限，会抛出异常SecurityException。</p>
<p>使用FileInputStream读取文件并输出内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"hello.txt"</span>); </span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> bytesRead = input.read(buf);</span><br><span class="line">    String data = <span class="keyword">new</span> String(buf, <span class="number">0</span>, bytesRead, <span class="string">"UTF-8"</span>); System.out.println(data);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    input.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读入到的是byte数组，我们使用String的带编码参数的构造方法将其转换为了String。这段代码假定一次read调用就读到了所有内容，且假定字节长度不超过1024。为了确保读到所有内容，可以逐个字节读取直到文件结束：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> bytesRead = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span>((b=input.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">    buf[bytesRead++] = (<span class="keyword">byte</span>)b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在没有缓冲的情况下逐个字节读取性能很低，可以使用批量读入且确保读到结尾</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> bytesRead = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>((bytesRead=input.read(buf, off, <span class="number">1024</span>-off))!=-<span class="number">1</span>)&#123; </span><br><span class="line">    off += bytesRead;</span><br><span class="line">&#125;</span><br><span class="line">String data = <span class="keyword">new</span> String(buf, <span class="number">0</span>, off, <span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure>


<p><strong>如果不确定文件内容的长度，但不希望一次性分配过大的byte数组，又希望将文件内容全部读入，怎么做呢？可以借助 ByteArrayOutputStream</strong></p>
<h3 id="ByteArrayInputStream-ByteArrayOutputStream（类）"><a href="#ByteArrayInputStream-ByteArrayOutputStream（类）" class="headerlink" title="ByteArrayInputStream/ByteArrayOutputStream（类）"></a>ByteArrayInputStream/ByteArrayOutputStream（类）</h3><p>它们的输入源和输出目标是字节数组</p>
<p><strong>ByteArrayOutputStream</strong></p>
<p>ByteArrayOutputStream的输出目标是一个byte数组，<strong>这个数组的长度是根据数据内容动态扩展的</strong>，它有两个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ByteArrayOutputStream</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ByteArrayOutputStream</span><span class="params">(<span class="keyword">int</span> size)</span><span class="comment">// 如果没有指定，则长度为32</span></span></span><br></pre></td></tr></table></figure>


<p>第二个构造方法中的size指定的就是初始的数组大小，如果没有指定，则长度为32。在调用write方法的过程中，如果数组大小不够，会进行扩展，扩展策略同样是指数扩展，每次至少增加一倍。</p>
<p>ByteArrayOutputStream有如下方法，可以方便地将数据转换为字节数组或字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">byte</span>[] toByteArray() <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">(String charsetName)</span></span></span><br></pre></td></tr></table></figure>

<p>toString()方法使用系统默认编码。</p>
<p>ByteArrayOutputStream中的数据也可以方便地写到另一个OutputStream：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>
<p>ByteArrayOutputStream还有如下额外方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// size方法返同当前写入的字节个数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>reset方法重置字节个数为0，reset后，可以重用已分配的数组。使用ByteArrayOutputStream，我们可以改进前面的读文件代码，确保将所有文件内容读入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"hello.txt"</span>); </span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    ByteArrayOutputStream output = <span class="keyword">new</span> ByteArrayOutputStream(); </span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> bytesRead = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>((bytesRead=input.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        output.write(buf, <span class="number">0</span>, bytesRead);</span><br><span class="line">    &#125;</span><br><span class="line">    String data = output.toString(<span class="string">"UTF-8"</span>); </span><br><span class="line">    System.out.println(data);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    input.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读入的数据先写入ByteArrayOutputStream中，读完后，再调用其toString方法获取完整数据。</p>
<p><strong>ByteArrayInputStream</strong></p>
<p>ByteArrayInputStream将byte数组包装为一个输入流，<strong>是一种适配器模式</strong>，它的构造方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ByteArrayInputStream</span><span class="params">(<span class="keyword">byte</span> buf[])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ByteArrayInputStream</span><span class="params">(<span class="keyword">byte</span> buf[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 第二个构造方法以buf中offset开始的length个字节为背后的数据。</span></span></span><br></pre></td></tr></table></figure>
<p>ByteArrayInput-Stream的所有数据都在内存，支持mark/reset重复读取。<br>为什么要将byte数组转换为InputStream呢？这与容器类中要将数组、单个元素转换为容器接口的原因是类似的，有很多代码是以InputStream/OutputSteam为参数构建的，它们构成了一个协作体系，将byte数组转换为InputStream可以方便地参与这种体系，复用代码。</p>
<h3 id="DataInputStream-DataOutputStream"><a href="#DataInputStream-DataOutputStream" class="headerlink" title="DataInputStream/DataOutputStream"></a>DataInputStream/DataOutputStream</h3><p>上面介绍的类都只能以字节为单位读写，如何以其他类型读写呢？比如int、double。可以使用</p>
<p>DataInputStream/DataOutputStream，它们都是装饰类。 </p>
<p>1.DataOutputStream</p>
<p>DataOutputStream是装饰类基类FilterOutputStream的子类，FilterOutputStream是Output-Stream的子类，它的构造方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DataOutputStream</span><span class="params">(OutputStream out)</span></span></span><br></pre></td></tr></table></figure>
<p>它接受一个已有的OutputStream，基本上将所有操作都代理给了它。DataOutputStream实现了DataOutput接口，可以以各种基本类型和字符串写入数据，部分方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeBoolean</span><span class="params">(<span class="keyword">boolean</span> v)</span> <span class="keyword">throws</span> IOException</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeInt</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeUTF</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<p>在写入时，DataOutputStream会将这些类型的数据转换为其对应的二进制字节，比如： </p>
<p>1)writeBoolean：写入一个字节，如果值为true，则写入1，否则0。 </p>
<p>2)writeInt：写入4个字节，最高位字节先写入，最低位最后写入。</p>
<p>3)writeUTF：将字符串的UTF-8编码字节写入，这个编码格式与标准的UTF-8编码略有不同，不过，我们不用关心这个细节。</p>
<p>我们来看一个例子，保存一个学生列表到文件中，学生类的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123; </span><br><span class="line">    String name; </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略构造方法和getter/setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>学生列表内容为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; students = Arrays.asList(<span class="keyword">new</span> Student[]&#123;</span><br><span class="line">    <span class="keyword">new</span> Student(<span class="string">"张三"</span>, <span class="number">18</span>, <span class="number">80.9</span>d), </span><br><span class="line">    <span class="keyword">new</span> Student(<span class="string">"李四"</span>,<span class="number">17</span>,<span class="number">67.5</span>d)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>将该列表内容写到文件students.dat中的代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeStudents</span><span class="params">(List&lt;Student&gt; students)</span> <span class="keyword">throws</span> IOException</span>&#123; </span><br><span class="line">    DataOutputStream output = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"students.dat"</span>));</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        output.writeInt(students.size()); </span><br><span class="line">        <span class="keyword">for</span>(Student s : students)&#123;</span><br><span class="line">            output.writeUTF(s.getName()); </span><br><span class="line">            output.writeInt(s.getAge()); </span><br><span class="line">            output.writeDouble(s.getScore());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        output.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先写了列表的长度，然后针对每个学生、每个字段，根据其类型调用了相应的write方法。</p>
<p>2.DataInputStream</p>
<p>DataInputStream是装饰类基类FilterInputStream的子类，FilterInputStream是Input-Stream的子类。 DataInputStream实现了DataInput接门，可以以各种基本类型和字符串读取数据，部分方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">readBoolean</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">readUTF</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>
<p>在读取时，DataInputStream会先按字节读进来，然后转换为对应的类型。</p>
<p>DataInputStream的构造方法接受一个InputStream：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DataInputStream</span><span class="params">(InputStream in)</span></span></span><br></pre></td></tr></table></figure>

<p>还是以上面的学生列表为例，我们来看怎么从文件中读进来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Student&gt; <span class="title">readStudents</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123; </span><br><span class="line">    DataInputStream input = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"students.dat"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = input.readInt();</span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> ArrayList&lt;Student&gt;(size); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line"></span><br><span class="line">            Student s = <span class="keyword">new</span> Student();</span><br><span class="line">            s.setName(input.readUTF()); </span><br><span class="line">            s.setAge(input.readInt()); </span><br><span class="line">            s.setScore(input.readDouble()); </span><br><span class="line">            students.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> students;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读基本是写的逆过程，代码比较简单，就不赘述了。使用DataInputStream/DataOutput-Stream读写对象，非常灵活，但比较麻烦，所以Java提供了序列化机制，我们在下章介绍。</p>
<h3 id="BufferedInputStream-BufferedOutputStream"><a href="#BufferedInputStream-BufferedOutputStream" class="headerlink" title="BufferedInputStream/BufferedOutputStream"></a>BufferedInputStream/BufferedOutputStream</h3><p>FileInputStream/FileOutputStream是没有缓冲的，按单个字节读写时性能比较低，虽然可以按字节数组读取以提高性能，但有时必须要按字节读写，怎么解决这个问题呢？方法是将文件流包装到缓冲流中。 BufferedInputStream内部有个字节数组作为缓冲区，读取时，先从这个缓冲区读，缓冲区读完了再调用包装的流读，它的构造方法有两个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in, <span class="keyword">int</span> size)</span></span></span><br></pre></td></tr></table></figure>
<p>size表示缓冲区大小，如果没有，默认值为8192。除了提高性能，BufferedInputStream也支持 mark/reset，可以重复读取。与BufferedInputStream类似，BufferedOutputStream的构造方法也有两个，默认的缓冲区大小也是8192，它的flush方法会将缓冲区的内容写到包装的流中。</p>
<p>在使用FileInputStream/FileOutputStream时，应该几乎总是在它的外面包上对应的缓冲类，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">InputStream input = <span class="keyword">new</span> BufferedInputStream( <span class="keyword">new</span> FileInputStream(<span class="string">"hello.txt"</span>));</span><br><span class="line"></span><br><span class="line">OutputStream output = <span class="keyword">new</span> BufferedOutputStream( <span class="keyword">new</span> FileOutputStream(<span class="string">"hello.txt"</span>));</span><br></pre></td></tr></table></figure>

<p>再比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DataOutputStream output = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"students.dat"</span>))); </span><br><span class="line">DataInputStream input = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"students.dat"</span>)));</span><br></pre></td></tr></table></figure>
<p>实用方法</p>
<p>可以看出，即使只是按二进制字节读写流，Java也包括了很多的类，虽然很灵活，但对于一些简单的需求，却需要写很多代码。实际开发中，经常需要将一些常用功能进行封装，提供更为简单的接口。下面我们提供一些实用方法，以供参考，这些代码都比较简单易懂，我们就不解释了。</p>
<p>复制输入流的内容到输出流，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(InputStream input, OutputStream output)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>]; </span><br><span class="line">    <span class="keyword">int</span> bytesRead = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((bytesRead = input.read(buf))!=-<span class="number">1</span>)&#123; </span><br><span class="line">        output.write(buf, <span class="number">0</span>, bytesRead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，在Java 9中，InputStream类增加了一个方法transferTo，可以实现相同功能，实现是类似的，具体代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">transferTo</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line">    Objects.requireNonNull(out, <span class="string">"out"</span>);</span><br><span class="line">    <span class="keyword">long</span> transferred = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[DEFAULT_BUFFER_SIZE]; <span class="comment">//buf的size大小是8192 </span></span><br><span class="line">    <span class="keyword">int</span> read;</span><br><span class="line">    <span class="keyword">while</span>((read = <span class="keyword">this</span>.read(buffer, <span class="number">0</span>, DEFAULT_BUFFER_SIZE)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        out.write(buffer, <span class="number">0</span>, read);</span><br><span class="line">        transferred += read;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> transferred;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将文件读入字节数组，这个方法调用了上面的复制方法，具体代码为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] readFileToByteArray(String fileName) <span class="keyword">throws</span> IOException&#123; </span><br><span class="line">    InputStream input = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">    ByteArrayOutputStream output = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        copy(input, output);</span><br><span class="line">        <span class="keyword">return</span> output.toByteArray();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将字节数组写到文件，代码为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeByteArrayToFile</span><span class="params">(String fileName, <span class="keyword">byte</span>[] data)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    OutputStream output = <span class="keyword">new</span> FileOutputStream(fileName); </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        output.write(data);</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        output.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Apache有一个类库Commons IO，里面提供了很多简单易用的方法，实际开发中，可以考虑使用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本节介绍了如何在Java中以二进制字节的方式读写文件，介绍了主要的流。</p>
<ul>
<li>InputStream/OutputStream:是抽象基类，有很多面向流的代码，以它们为参数，比如本节介绍的 copy方法。</li>
<li>FileInputStream/FileOutputStream:流的源和目的地是文件。 </li>
<li>ByteArrayInputStream/ByteArrayOutputStream:源和目的地是字节数组，作为输入相当于适配器，作为输出封装了动态数组，便于使用。</li>
<li>DataInputStream/DataOutputStream:装饰类，按基本类型和字符串读写流。 </li>
<li>BufferedInputStream/BufferedOutputStream:装饰类，提供缓冲，FileInputStream/FileOutputStream一般总是应该用该类装饰。</li>
</ul>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-03-01</span><i class="fa fa-tag"></i><span class="leancloud_visitors"></span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2021/03/01/Java文件与流/,Vector,Java文件与流,;" target="_blank" rel="noopener"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2021/03/01/%E5%8C%BA%E5%9F%9F%E6%A3%80%E7%B4%A2%E5%92%8C-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/" title="区域检索和_数组不可变">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2021/02/28/%E9%94%A6%E6%A0%87%E8%B5%9B%E6%8E%92%E5%BA%8F/" title="锦标赛排序">下一篇</a></li></ul></div><script src="/js/visitors.js"></script><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@latest/dist/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:false|| false, 
  app_id:'',
  app_key:'',
  placeholder:'念念不忘，必有回响...',
  path: window.location.pathname,
  serverURLs: '',
  visitor:true,
  recordIP:true,
  avatar:'mp'
})</script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/js/baidu-tongji.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":200,"height":350},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body></html>